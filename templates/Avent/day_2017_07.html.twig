{% extends 'Avent/day.html.twig' %}

{% set year = 2017 %}

{% block article_title "Jour 7 - DÃ©coupler Form et votre modÃ¨le" %}

{% block article_content %}
    <style type="text/css">
        i {
            font-family: sans-serif;
        }
    </style>
    <h1 id="dÃ©coupler-form-et-votre-modÃ¨le">DÃ©coupler Form et votre modÃ¨le</h1>

    <p>Le composant Form est un de ceux qui ont largement contribuÃ© au succÃ¨s et Ã  la popularitÃ© de lâ€™Ã©cosystÃ¨me Symfony. Il propose un systÃ¨me puissant et flexible qui permet dâ€™unifier et de simplifier la gÃ©nÃ©ration et le traitement de formulaires. Il est aussi connu pour implÃ©menter plusieurs <i>design patterns</i>, qui lui permettent dâ€™Ãªtre Ã  la fois rapide Ã  utiliser, et suffisamment flexible pour sâ€™adapter Ã  tous les besoins, sans se retrouver bloquÃ© devant de la magie noire impÃ©nÃ©trable (le cauchemar de tout dÃ©veloppeur).</p>

    <p>Je ne mâ€™Ã©tendrai pas sur les fonctionnalitÃ©s de ce composant et de son intÃ©gration avec Symfony Ã©tant donnÃ© sa popularitÃ©. Cependant, dans cet article je vais parler de son lien avec notre modÃ¨le de donnÃ©es : nos entitÃ©s.</p>

    <p>Je vais prendre un exemple simple, que lâ€™on suivra tout au long de lâ€™article.</p>

    <p>Voici ma <i>user story :</i><br>
        <i>En tant que gestionnaire de mon application de vente de camion transporteurs,</i> <br>
        <i>quand je suis sur le backoffice de mon application,</i> <br>
        <i>je souhaite pouvoir ajouter un modÃ¨le tout en renseignant ses informations propres : modÃ¨le, marque, annÃ©e de construction, kilomÃ¨tres au compteur.</i></p>

    <p>ProTip pour rÃ©pondre Ã  ce besoin : <a href="https://afsy.fr/avent/2017/01-easyadminbundle-l-arriere-guichet-easy-peasy">lire l'excellent lâ€™article de Baptiste sur EasyAdmin ğŸ˜„</a><br>
        Fin. Merci dâ€™avoir lu !</p>



    <h2 id="pourquoi-on-aime-form">Pourquoi on aime Form</h2>

    <p>Avant de rentrer dans le vif du sujet, je tiens quand mÃªme Ã  rappeler pourquoi on aime Form, et particuliÃ¨rement Ã  travers ses choix de conception :</p>

    <p>Câ€™est un composant <strong>assez facile dâ€™accÃ¨s</strong>. Il est aisÃ© de crÃ©er son premier formulaire en quelques lignes en suivant la documentation.</p>

    <p>Voici notre entitÃ© pour rÃ©fÃ©rence :</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeavyTruck</span>
{</span>
    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @Assert</span>\Length("min"=5)
     *<span class="hljs-phpdoc"> @var</span> string
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-variable">$reference</span>;

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @Assert</span>\Valid
     *<span class="hljs-phpdoc"> @var</span> Brand
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-variable">$brand</span>;

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @Assert</span>\Length("min"=4, "max"=4)
     *<span class="hljs-phpdoc"> @var</span> int
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-variable">$buildYear</span>;

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @var</span> float
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-variable">$kilometers</span>;

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @return</span> string
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReference</span><span class="hljs-params">()</span>: <span class="hljs-title">string</span>
    {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;reference;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @param</span> string $reference
     *<span class="hljs-phpdoc"> @return</span> HeavyTruck
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setReference</span><span class="hljs-params">(string <span class="hljs-variable">$reference</span>)</span>: <span class="hljs-title">HeavyTruck</span>
    {</span>
        <span class="hljs-variable">$this</span>-&gt;reference = <span class="hljs-variable">$reference</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @return</span> Brand
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBrand</span><span class="hljs-params">()</span>: <span class="hljs-title">Brand</span>
    {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;brand;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @param</span> Brand $brand
     *<span class="hljs-phpdoc"> @return</span> HeavyTruck
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBrand</span><span class="hljs-params">(Brand <span class="hljs-variable">$brand</span>)</span>: <span class="hljs-title">HeavyTruck</span>
    {</span>
        <span class="hljs-variable">$this</span>-&gt;brand = <span class="hljs-variable">$brand</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @return</span> int
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBuildYear</span><span class="hljs-params">()</span>: <span class="hljs-title">int</span>
    {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;buildYear;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @param</span> int $buildYear
     *<span class="hljs-phpdoc"> @return</span> HeavyTruck
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBuildYear</span><span class="hljs-params">(int <span class="hljs-variable">$buildYear</span>)</span>: <span class="hljs-title">HeavyTruck</span>
    {</span>
        <span class="hljs-variable">$this</span>-&gt;buildYear = <span class="hljs-variable">$buildYear</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @return</span> float
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKilometers</span><span class="hljs-params">()</span>: <span class="hljs-title">float</span>
    {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;kilometers;
    }

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @param</span> float $kilometers
     *<span class="hljs-phpdoc"> @return</span> HeavyTruck
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setKilometers</span><span class="hljs-params">(<span class="hljs-variable">$kilometers</span>)</span>: <span class="hljs-title">HeavyTruck</span>
    {</span>
        <span class="hljs-variable">$this</span>-&gt;kilometers = <span class="hljs-variable">$kilometers</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>;
    }
}</code></pre>

    <p>Et le formulaire associÃ© :</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeavyTruckType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractType</span>
{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildForm</span><span class="hljs-params">(FormBuilderInterface <span class="hljs-variable">$builder</span>, array <span class="hljs-variable">$options</span>)</span>
    {</span>
        <span class="hljs-variable">$builder</span>
            -&gt;add(<span class="hljs-string">'reference'</span>)
            -&gt;add(<span class="hljs-string">'brand'</span>)
            -&gt;add(<span class="hljs-string">'buildYear'</span>)
            -&gt;add(<span class="hljs-string">'kilometers'</span>)
        ;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">configureOptions</span><span class="hljs-params">(OptionsResolver <span class="hljs-variable">$resolver</span>)</span>
    {</span>
        <span class="hljs-variable">$resolver</span>-&gt;setDefaults([
            <span class="hljs-string">'data_class'</span> =&gt; HeavyTruck::<span class="hljs-class"><span class="hljs-keyword">class</span>,
        ]);
    }
}</span></code></pre>

    <p>Je ne parlerai pas ici des options propres Ã  chaque champ car cela ne nous intÃ©resse pas ici, et je veux garder des exemples simples pour me concentrer sur les donnÃ©es et non la configuration.</p>

    <p>On note que cette approche basique a lâ€™avantage de regrouper la gÃ©nÃ©ration du formulaire et son remplissage, grÃ¢ce Ã  lâ€™implÃ©mentation native du composant <code>PropertyAccess</code>.</p>

    <p>Ce duo entitÃ© / formulaire est idÃ©al dans un contexte de <abbr title="Rapid Application Development" lang="en">RAD</abbr> car il permet de dâ€™implÃ©menter rapidement des write actions sur son modÃ¨le, tout en ayant quelque chose de clair et extensible. Je passe la partie "contrÃ´leur" que vous connaissez bien.</p>

    <p>Notre besoin ici est simple, cette â€œmagieâ€ nous suffit amplement.</p>

    <p>Mais que se passe-t-il si notre besoin Ã©volue, si on doit faire des traitements plus poussÃ©s sur nos champs ? Si on veut utiliser plusieurs champs pour ne remplir quâ€™une propriÃ©tÃ© ? <br>
        On peut adapter la magie par lâ€™implÃ©mentation de plusieurs points dâ€™entrÃ©es permettant de mettre sa propre logique de traitement, câ€™est Ã  dire les
        <a href="https://symfony.com/doc/4.0/form/dynamic_form_modification.html"><code>FormEvents</code></a> et les <a href="https://symfony.com/doc/current/form/data_transformers.html"><code>DataTransformers</code></a>, ce qui est suffisant dans la plupart des cas.</p>

    <p>La force du composant Form rÃ©side aussi dans son implÃ©mentation du <i>design pattern</i> <code>Composite</code>, qui apporte toute la flexibilitÃ© nÃ©cessaire pour crÃ©er des formulaires complexes.</p>



    <h2 id="pourquoi-form-nest-pas-optimisÃ©-pour-votre-modÃ¨le">Pourquoi Form nâ€™est pas optimisÃ© pour votre modÃ¨le</h2>

    <p>Revenons sur lâ€™exemple que jâ€™ai fourni en dÃ©but dâ€™article. Câ€™est un exemple typique quâ€™on peut trouver dans la documentation de Symfony. Comme je lâ€™ai expliquÃ©, cela fonctionne trÃ¨s bien et est trÃ¨s pratique dans de nombreux cas. <br>
        Pourquoi ? Parce que la classe de formulaire est <strong>fortement couplÃ©e</strong> au modÃ¨le.</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">configureOptions</span><span class="hljs-params">(OptionsResolver <span class="hljs-variable">$resolver</span>)</span>
{</span>
    <span class="hljs-variable">$resolver</span>-&gt;setDefaults([
        <span class="hljs-string">'data_class'</span> =&gt; HeavyTruck::<span class="hljs-class"><span class="hljs-keyword">class</span>,
    ]);
}</span></code></pre>

    <p>En spÃ©cifiant <code>data_class</code> directement sur lâ€™entitÃ©, voici ce qui va se passer Ã  la soumission du formulaire (je nâ€™ai retenu que ce qui nous intÃ©resse ici) : <br>
        1) les donnÃ©es du formulaire sont passÃ©es dans chaque â€œchampâ€ <br>
        2) Un objet <code>HeavyTruck</code> est hydratÃ© avec ces donnÃ©es <br>
        3) Lâ€™objet hydratÃ© est validÃ©</p>

    <p>Ce qui signifie quâ€™on crÃ©e / modifie un objet mÃ©tier et quâ€™on valide ses donnÃ©es ensuite. Câ€™est problÃ©matique en terme de conception.</p>

    <p>Imaginons que dans mon application, pour une raison (que la raison ignore ğŸ˜„) je souhaite faire un <code>flush()</code> sur chaque requÃªte (par exemple dans un <i>listener</i> branchÃ© sur un <i>kernel event</i>).</p>

    <p>Je passe dans mon formulaire, lâ€™objet est hydratÃ© ; la validation sâ€™opÃ¨re, disons quâ€™elle renvoie des erreurs. Lâ€™objet ne match pas les critÃ¨res de validations, il ne doit en aucun cas se retrouver persistÃ© auquel cas votre base de donnÃ©e se retrouvera corrompue.</p>

    <p>Et pourtantâ€¦ si vous utilisez un ORM et que lâ€™objet qui vient dâ€™Ãªtre hydratÃ© est dÃ©jÃ  <i>managÃ©</i>, et bien Doctrine va computer les changements et ils se retrouveront dans votre base au moment au moment du <code>flush()</code> ! <br>
        En fait, mÃªme sans avoir de listener qui flush, il suffit quâ€™un <code>flush()</code> se soit perdu quelque part avant la fin de la requÃªte (dans un <i>manager</i>, ou juste avant de faire le rendu de votre template, cas classique).</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TruckController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractController</span>

// $<span class="hljs-title">truck</span> <span class="hljs-title">est</span> <span class="hljs-title">inject</span>Ã© <span class="hljs-title">par</span> <span class="hljs-title">un</span> <span class="hljs-title">ParamConverter</span>, <span class="hljs-title">il</span> <span class="hljs-title">est</span> <span class="hljs-title">manag</span>Ã© <span class="hljs-title">par</span> <span class="hljs-title">notre</span> <span class="hljs-title">ORM</span>
<span class="hljs-title">public</span> <span class="hljs-title">function</span> <span class="hljs-title">editAction</span>(<span class="hljs-title">Request</span> $<span class="hljs-title">request</span>, <span class="hljs-title">Truck</span> $<span class="hljs-title">truck</span>)
{</span>
    <span class="hljs-variable">$form</span> = <span class="hljs-variable">$this</span>-&gt;formFactory-&gt;createForm(TruckType::<span class="hljs-class"><span class="hljs-keyword">class</span>, $<span class="hljs-title">truck</span>);
    <span class="hljs-title">if</span> ($<span class="hljs-title">form</span>-&gt;<span class="hljs-title">isValid</span>()) {</span>
        <span class="hljs-variable">$this</span>-&gt;entityManager-&gt;flush();
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;templating-&gt;render(<span class="hljs-string">'list'</span>);
    }

    <span class="hljs-comment">// oh un flush perdu</span>
    <span class="hljs-variable">$this</span>-&gt;entityManager-&gt;flush();
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;templating-&gt;render(<span class="hljs-string">'edit'</span>);
}</code></pre>

    <p>Ceci est un simple exemple pour montrer que le cas peut exister. Il est de notre responsabilitÃ© en tant que dÃ©veloppeurs de concevoir nos applications afin de limiter au mieux les effets de bord, <a href="https://en.wikipedia.org/wiki/Defensive_programming">en appliquant un peu la loi de Murphy</a>.</p>

    <p>Lâ€™idÃ©e Ã  retenir ici est donc quâ€™il faut Ã©viter dâ€™hydrater un objet mÃ©tier invalide (= non validÃ©), et que si vous utilisez Form en mode RAD, alors vous ne pourrez pas lâ€™empÃªcher.</p>

    <p>Cependant, comme abordÃ© plus haut, il reste toujours la possibilitÃ© dâ€™utiliser des <code>FormEvents</code> pour appliquer de la logique avant que lâ€™objet soit hydratÃ©.</p>

    <p>Lâ€™utilisation des <code>FormEvents</code> nâ€™est pas trÃ¨s intuitive selon moi. <br>
        La donnÃ©e contenue dans les <i>events</i> nâ€™est pas toujours fournie sous le mÃªme format, parfois sous forme de tableau, parfois sous forme dâ€™objet hydratÃ© â€” ce qui fait sens au vu du workflow du composant mais qui peut Ãªtre un peu dÃ©routant Ã  lâ€™utilisation. <br>
        De plus ces listeners sont fortement couplÃ©s Ã  la classe de formulaire elle-mÃªme, et il nâ€™est pas trÃ¨s sain dâ€™essayer de les rendre rÃ©utilisables. Les <code>DataTransformers</code> sont plus adaptÃ©s Ã  ce cas de figure mais permettent de transformer un champ Ã  la fois. <br>
        Il peut Ãªtre donc un peu fastidieux de passer par ces Ã©tapes pour des besoins complexes.</p>

    <p>Pour valider les donnÃ©es avant quâ€™elles ne soient effectivement utilisÃ©es, lâ€™utilisation des <code>FormEvents</code> ne semble pas vraiment adaptÃ©e : il faudrait valider alors un array de donnÃ©es en reprenant les rÃ¨gles de validation dÃ©finies dans lâ€™entitÃ© et lever une <code>FormError</code> manuellement pour chaqueâ€¦ Ã§a reste faisable mais pas vraiment intuitif selon moi.</p>

    <p>
        En bref :
        <ul>
            <li>une des qualitÃ©s du composant Form est quâ€™il permet de facilement crÃ©er et modifier des entitÃ©s Ã  l'aide d'un couplage ;</li>
            <li>ce couplage est compensÃ© par des points dâ€™entrÃ©e qui permettent dâ€™implÃ©menter votre propre logique ;</li>
            <li>cette faÃ§on de faire sâ€™apparente un peu Ã  du â€œbidouillageâ€, ce qui pose des limites dans un contexte dâ€™application plus complexe.</li>
        </ul>
    </p>


    <p>Notre mission : rendre nos formulaires indÃ©pendants de nos entitÃ©s.</p>
    <br><br>
    <img src="{{ asset('bundles/afsyfront/images/avent/2017/07/challenge_accepted.gif') }}" alt="Challenge accepted!">



    <h2 id="quelques-pistes">Quelques pistes</h2>



    <h3 id="utiliser-un-objet-intermÃ©diaire">Utiliser un objet intermÃ©diaire</h3>

    <p>Pour lâ€™instant, nous avons directement liÃ© notre formulaire Ã  notre entitÃ©. <br>
        Pourquoi ne pas envisager de le lier Ã  un objet intermÃ©diaire ? <br>
        Quelques avantages que cela reprÃ©sente : <br>
        <ul>
            <li>On hydrate pas le mÃ©tier directement, mais un objet qui nâ€™est pas fait pour Ãªtre persistÃ© ;</li>
            <li>On ne devient plus dÃ©pendant des propriÃ©tÃ©s / setters de lâ€™entitÃ©, et on libÃ¨re une couche de traitement supplÃ©mentaire pour jouer sur nos donnÃ©es ;</li>
            <li>On peut avoir un objet Ã  lâ€™image du formulaire et pas Ã  celui du mÃ©tier ;</li>
            <li>On peut appliquer la validation sur cet objet avant dâ€™hydrater notre objet mÃ©tier.</li>
        </ul>

    <p>Assez de blabla, voici un exemple :</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeTruckDetailsDTO</span>
{</span>
    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @Assert</span>\Length("min"=5)
     *<span class="hljs-phpdoc"> @var</span> string
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-variable">$reference</span>;

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @Assert</span>\Valid
     *<span class="hljs-phpdoc"> @var</span> Brand
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-variable">$brand</span>;

    <span class="hljs-comment">/**
     *<span class="hljs-phpdoc"> @Assert</span>\Length("min"=4, "max"=4)
     *<span class="hljs-phpdoc"> @var</span> string
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-variable">$buildYear</span>;
}</code></pre>

    <p><i>DTO = Data Transfer Object, ce nâ€™est quâ€™un nommage appelez Ã§a comme vous voulez</i></p>

    <p>On voit ici que le <abbr title="Data Transfer Object" lang="en">DTO</abbr> contient nos rÃ¨gles de validation. On peut appliquer ce principe rÃ©cursivement Ã  nos â€œsous-classesâ€ de formulaire. <br>
        Form va donc valider que le DTO est valide, et on pourra setter nos propriÃ©tÃ©s de champ manuellement.</p>

    <p>Dans notre formulaire, aucune mention nâ€™est faite dâ€™aucune entitÃ©.</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeavyTruckType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractType</span>
{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildForm</span><span class="hljs-params">(FormBuilderInterface <span class="hljs-variable">$builder</span>, array <span class="hljs-variable">$options</span>)</span>
    {</span>
        <span class="hljs-variable">$builder</span>
            -&gt;add(<span class="hljs-string">'reference'</span>)
            -&gt;add(<span class="hljs-string">'brand'</span>)
            -&gt;add(<span class="hljs-string">'buildYear'</span>)
            -&gt;add(<span class="hljs-string">'kilometers'</span>)
        ;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">configureOptions</span><span class="hljs-params">(OptionsResolver <span class="hljs-variable">$resolver</span>)</span>
    {</span>
        <span class="hljs-variable">$resolver</span>-&gt;setDefaults([
            <span class="hljs-string">'data_class'</span> =&gt; ChangeTruckDetailsDTO::<span class="hljs-class"><span class="hljs-keyword">class</span>,
        ]);
    }
}</span></code></pre>

    <p>Il est ok selon moi dâ€™implÃ©menter une mÃ©thode qui permet d'hydrater le DTO avec les donnÃ©es de lâ€™entitÃ©, ce qui est bien pratique dans un formulaire de modification, exemple :</p>



    <pre class="prettyprint"><code class="language-php hljs ">
<span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeTruckDetailsDTO</span>
{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFromEntity</span><span class="hljs-params">(HeavyTruck <span class="hljs-variable">$entity</span>)</span>
    {</span>
        <span class="hljs-variable">$truck</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">static</span>;

        <span class="hljs-variable">$truck</span>-&gt;reference = <span class="hljs-variable">$entity</span>-&gt;getReference();
        <span class="hljs-variable">$truck</span>-&gt;brand = <span class="hljs-variable">$entity</span>-&gt;getBrand();
        <span class="hljs-variable">$truck</span>-&gt;buildYear = <span class="hljs-variable">$entity</span>-&gt;getBuildYear();

        <span class="hljs-keyword">return</span> <span class="hljs-variable">$truck</span>;
    }
}</code></pre>

    <p>Et on peut ainsi avoir notre formulaire dÃ©couplÃ© de lâ€™entitÃ© !</p>



    <pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TruckController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractController</span>
{</span>

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">editAction</span><span class="hljs-params">(Request <span class="hljs-variable">$request</span>, HeavyTruck <span class="hljs-variable">$truck</span>)</span>
    {</span>
        <span class="hljs-variable">$dto</span> = ChangeTruckDetailsDTO::createFromEntity(<span class="hljs-variable">$truck</span>);
        <span class="hljs-variable">$form</span> = <span class="hljs-variable">$this</span>-&gt;formFactory-&gt;createForm(ChangeTruckDetailsDTO::<span class="hljs-class"><span class="hljs-keyword">class</span>, $<span class="hljs-title">dto</span>);

        <span class="hljs-title">if</span> ($<span class="hljs-title">form</span>-&gt;<span class="hljs-title">isValid</span>()) {</span>
        <span class="hljs-comment">// on est libre ici, je n'ai pas fait de traitement spÃ©cifique mais c'est possible.</span>
            <span class="hljs-variable">$truck</span>-&gt;setReference(<span class="hljs-variable">$dto</span>-&gt;reference);
            <span class="hljs-variable">$truck</span>-&gt;setBrand(<span class="hljs-variable">$dto</span>-&gt;brand);
            <span class="hljs-variable">$truck</span>-&gt;setBuildYear(<span class="hljs-variable">$dto</span>-&gt;buildYear);

            <span class="hljs-variable">$this</span>-&gt;entityManager-&gt;flush();

            <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;templating-&gt;render(<span class="hljs-string">'list'</span>);
        }

        <span class="hljs-comment">// oh un flush perdu, mais cette fois $truck n'est pas modifiÃ©</span>
        <span class="hljs-variable">$this</span>-&gt;entityManager-&gt;flush();

        <span class="hljs-keyword">return</span> <span class="hljs-variable">$this</span>-&gt;templating-&gt;render(<span class="hljs-string">'edit'</span>);
    }
}</code></pre>



    <h3 id="problÃ¨mes-que-cela-pose">ProblÃ¨mes que cela pose :</h3>

    <p>Tout cela est bien beau, mais on se retrouve avec une classe de plus Ã  gÃ©rer. <br>
        S'imposer de valider un DTO avant dâ€™hydrater lâ€™entitÃ© correspondante implique une dupliquation des rÃ¨gles de validation, et donc de complexifier leur maintenance. <br>
        Je pense que c'est mauvaise idÃ©e de mettre ces rÃ¨gles uniquement dans le DTO car il devient alors impossible de valider directement lâ€™entitÃ©, on pÃ©nalise alors tous les autres cas oÃ¹ lâ€™on crÃ©e des objets sans passer par le formulaire. <br>
        Câ€™est pour moi un vrai frein Ã  cette alternative.</p>

    <p>Le fait est quâ€™honnÃªtement, il nâ€™est pas si courant dâ€™avoir besoin dâ€™un modÃ¨le pour le formulaire qui diffÃ¨re de celui de lâ€™entitÃ©. Du coup il semble un peu <i>overkill</i> de crÃ©er un DTO puis de setter manuellement les propriÃ©tÃ©s alors que Form implÃ©mente tout ce quâ€™il faut pour Ã§a. Et dans le combat conception <i>versus</i> pragmatisme, câ€™est souvent le pragmatisme qui l'emporte.</p>

    <p>Martin Fowler est lui mÃªme assez mitigÃ© sur l'utilisation des DTO dans ce genre de contexte : <a href="https://martinfowler.com/bliki/LocalDTO.html">https://martinfowler.com/bliki/LocalDTO.html</a> (en anglais). <br>
        Marco Pivetta (Ocramius), lui, recommande cet usage pour les formulaires.</p>

    <p>Personnellement, je ne recommande pas dâ€™utiliser cette pratique sur des petites applications qui nâ€™ont pas de gros besoins Ã©volutifs. <br>
        Cependant je trouve cette approche intÃ©ressante si vous aimeriez avoir un formulaire qui diffÃ¨re un peu de la faÃ§on dont votre objet mÃ©tier est fait, et/ou que vous portez beaucoup dâ€™importance Ã  votre conception applicatif et que cela ne vous pose pas de problÃ¨me dâ€™y ajouter cette couche.</p>



    <h2 id="pour-rÃ©sumer">Pour rÃ©sumer</h2>

    <p>Form excelle pour crÃ©er des formulaires complexes pour notre modÃ¨le, mais pour cela il doit Ãªtre y Ãªtre fortement couplÃ©, ce qui nâ€™est pas sans danger pour notre application. On peut ajouter une couche â€œtamponâ€ avec un DTO mais cela alourdit le dÃ©veloppement des formulaires, qui est pourtant assez orientÃ© RAD.</p>

    <p>Alors oui, cet article se termine un peu sur un goÃ»t amerâ€¦ mais cela correspond Ã  la rÃ©alitÃ© !</p>

    <p>Je pense quâ€™il serait intÃ©ressant que ce questionnement ait lieu dans le dÃ©veloppement du composant Form. Je ferai peut-Ãªtre une RFC si lâ€™article fait des remous ğŸ˜›</p>

    <h2 id="ressources">Ressources - pour aller plus loin</h2>

    <p><a href="http://ocramius.github.io/doctrine-best-practices/#/47" lang="en">"Doctrine Best Practices" par Marco Pivetta</a></p>
    <p><a href="https://www.youtube.com/watch?v=Svndnw8n_SY">"Ne laissez pas les formulaires Symfony influencer votre modÃ¨le" par Jeremy Barthe</a></p>
    <p><a href="https://stovepipe.systems/post/avoiding-entities-in-forms" lang="en">"Avoiding Entities in Forms" par Iltar van der Berg (en anglais)</a></p>
{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('bundles/afsyfront/images/avent/remi_andrieux.jpg') }}" alt="RÃ©mi Andrieux" />
{% endblock %}

{% block article_bio %}
    <h2>
        <a href="{% block author_url %}https://twitter.com/pimolo__{% endblock %}" target="_blank">
            {% block article_author %}RÃ©mi Andieux{% endblock %}
        </a>
    </h2>
    <p>
        DÃ©veloppeur chez MyLittleBox.
    </p>
{% endblock %}
