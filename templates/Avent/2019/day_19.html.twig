{% extends 'Avent/day.html.twig' %}

{% set year = 2019 %}

{% block article_title "Jour 19 - Comment tester du code non-d√©terministe¬†?" %}

{% block article_content_md %}
# Comment tester du code non-d√©terministe¬†?

Je ne sais pas si vous avez remarqu√©, mais il y a certaines √©quipes de d√©veloppement qui font des choses √©tranges avec leurs projets. Des choses dont tout le monde parle, mais on n'en voit pas la couleur.

Pas des fant√¥mes, non.

Je parle des tests.

Et tr√®s souvent, quand on parle de tests, on voit ce genre de choses¬†:

```php
class Math
{
    public function add(float $a, float $b): float
    {
        return $a + $b;
    }
}
```

```php
class MathTest
{
    public function testAdd(): void
    {
        $math = new Math();

        static::assertSame(3, $math->add(1, 2));
    }
}
```

Whoa¬†! üéâ

Super, nous savons tester notre code¬†!

Et ce code a une particularit√©¬†: il est **d√©terministe**.

## Un peu d'explications

D'apr√®s [Wiktionary](https://fr.wiktionary.org/wiki/d%C3%A9terminisme), voici la d√©finition du d√©terminisme¬†:
> D√©terminisme¬†: (Informatique) Qualit√© des syst√®mes, des processus dont l‚Äôissue ne d√©pend que des conditions initiales.

Ce qui veut dire que si vous connaissez les param√®tres d'entr√©e, vous savez pr√©voir la sortie, quelle que soit la situation.

La plupart des choses que l'on fait sont d√©terministes car elles d√©pendent de donn√©es "fixes". Un nombre, une cha√Æne de caract√®res, une date, etc.

Mais lorsque nos algorithmes ont certains besoins, nous devrons utiliser du code non-d√©terministe.

C'est le cas par exemple de la gestion des donn√©es **al√©atoires**.

G√©n√©rer un identifiant unique dans tout l'univers, ou des donn√©es al√©atoires en g√©n√©ral, est une t√¢che ardue pour un ordinateur. Ce qui est encore plus ardu, c'est de pr√©voir le r√©sultat.

Avec des standards comme [UUID](https://fr.wikipedia.org/wiki/Universal_Unique_Identifier), on peut conna√Ætre la **taille** et le **format** des informations en sortie, mais pas le **contenu**. Les algorithmes sont suffisamment g√©nialement cr√©√©s pour qu'il soit "quasiment impossible" d'avoir deux fois la m√™me valeur avec deux ordinateurs diff√©rents.

Et votre code √† vous peut d√©pendre de ce genre de situation.

## Un exemple

Je vais prendre l'exemple d'un projet que je d√©veloppe depuis quelques ann√©es d√©j√† et qui est li√© au [jeu de r√¥le](https://fr.wikipedia.org/wiki/Jeu_de_r%C3%B4le).

Lorsque l'on cr√©e un personnage dans un jeu de r√¥le, souvent, on va lancer des d√©s üé≤ pour d√©terminer le score d'une caract√©ristique. C'est donc une valeur **al√©atoire**.

Si vous avez l'habitude des jets de d√©s, on peut repr√©senter un jet de d√© au format `2d6+3`, correspondant au jet de 2 d√©s √† 6 faces, dont on ajoute 3 au r√©sultat total. Il nous faut donc 3 param√®tres en entr√©e (pour simplifier √©videmment) : le nombre de d√©s, le nombre de faces pour chaque d√©, et un nombre √† additionner √† la fin.

## G√©n√©rer de l'al√©atoire

Cr√©ons donc ce service qui va jeter un d√©¬†:

```php
namespace App;

class DiceRoller
{
    public function roll(int $sides, int $multiplier = 1, int $offset = 0): int
    {
        return random_int(1, $sides) * $multiplier + $offset;
    }
}
```

> Note¬†: la classe se situe dans le _namespace_ `App`, et ce pour une bonne raison (continuez la lecture de cet article pour comprendre pourquoi).<br>
> De mani√®re g√©n√©rale, dans vos projets, toutes vos classes seront dans des espaces de noms.

Nous utilisons `random_int()`, une fonction native de PHP permettant de g√©n√©rer un nombre entier al√©atoire entre deux entiers.

Une fois fait, nous pouvons nous en servir dans nos propres services¬†:

```php// Roll 2d6+3
$diceRoller->roll(2, 6, 3);
```

> Note¬†: tous les nombres devraient √™tre valid√©s pour √™tre des entiers **positifs**, c'est un besoin m√©tier, mais nous n'allons pas revenir l√†-dessus car nous sommes dans un exemple. Notez simplement que si vous devez impl√©menter un tel syst√®me, il faudra imp√©rativement valider vos variables d'entr√©e.

Une question subsiste cependant¬†: **Comment tester ce code¬†?**

La r√©ponse n'est pas simple, mais il existe diff√©rents cas¬†:

* Tester directement la m√©thode `DiceRoller::roll()`
* Tester un service qui _d√©pend_ du `DiceRoller`

√âtrangement, le second cas est bien plus simple √† r√©aliser que le premier.

## Tester le code qui g√©n√®re une donn√©e al√©atoire

Pour tester le `DiceRoller`, je vais proposer progressivement trois alternatives, dans l'ordre de leur "fiabilit√©".

Nous partirons du principe que PHPUnit sera utilis√© pour tester le code.

## Premier essai¬†: R√©aliser un nombre cons√©quent de tests

Cette solution se pr√©sente sous cette forme¬†:

```php
namespace Tests\App;

use App\DiceRoller;
use PHPUnit\Framework\TestCase;

class DiceRollerTest extends TestCase
{
    /**
     * @dataProvider provide¬†dice¬†rolls
     */
    public function test¬†dice¬†roller¬†result¬†is¬†in¬†dice¬†range(int $sides, int $multiplier, int $offset): void
    {
        $diceRoller = new DiceRoller();

        $result = $diceRoller->roll($sides, $multiplier, $offset);

        static::assertGreaterThanOrEqual(1 * $multiplier + $offset, $result);
        static::assertLessThanOrEqual($sides * $multiplier + $offset, $result);
    }

    public function provide¬†dice¬†rolls(): \Generator
    {
        $sidesToTest = [4, 6, 8, 12, 20]; // d4, d6, etc.
        $multipliersToTest = range(1, 10); // Up to 10 dices at the same time.
        $offsetsToTest = [1, 2, 3, 4, 5]; // Not too much, that's already a lot.

        foreach ($sidesToTest as $sides) {
            foreach ($multipliersToTest as $multiplier) {
                foreach ($offsetsToTest as $offset) {
                    yield "$sides-$multiplier-$offset" => [$sides, $multiplier, $offset];
                }
            }
        }
    }
}
```

Et √† l'ex√©cution, on aura quelque chose de ce style¬†:

```
/var/www/dice_roller $ php phpunit.phar DiceRollerTest.php
PHPUnit 8.4.3 by Sebastian Bergmann and contributors.

...............................................................  63 / 250 ( 25%)
............................................................... 126 / 250 ( 50%)
............................................................... 189 / 250 ( 75%)
.............................................................   250 / 250 (100%)

Time: 130 ms, Memory: 18.00 MB

OK (250 tests, 1000 assertions)
```

Et l√†‚Ä¶ On pourrait se dire _"Super ! J'ai 250 tests pour ma classe, c'est merveilleux !"_.

Ou pas.

En r√©alit√©, avec le code ci-dessus, nous avons un probl√®me : chaque ex√©cution de `$diceRoller->roll()` va g√©n√©rer un nombre al√©atoire et nous n'avons **aucun moyen de pr√©dire sa valeur**. La seule chose que nous pouvons faire (et qui est faite dans ce test) c'est pr√©dire son **champ de valeurs possibles**. Et √©videmment, vu que notre code est bien fait, cela va fonctionner sans probl√®me.

Pour tenter de _"solutionner"_ ce probl√®me, on peut essayer de d√©terminer des **solutions statistiquement stables**.

En effet, si l'on ex√©cute une batterie de jets de d√©s, mettons `2d6+3`, en fonction du nombre de jets, la moyenne de r√©sultats n'est pas toujours la m√™me, d'une part car les nombres g√©n√©r√©s par PHP ne sont pas "r√©ellement al√©atoires", on dit qu'ils sont "pseudo-al√©atoires", et d'autre part, parce que la distribution des r√©sultats ne peut √™tre "stable" que de fa√ßon statistique et th√©orique. En pratique, c'est rarement le cas (c'est le principe m√™me du concept de _hasard_, finalement‚Ä¶)

Cr√©ons un petit script pour effectuer de nombreux jets de d√©s¬†:

```php
$diceRoller = new App\DiceRoller();

$count = 1000000;
$results = [];

for ($i = 1; $i <= $count; $i++) {
    $results[] = $diceRoller->roll(2, 6, 3);
}

// Average value
echo array_sum($results) / $count, "\n";
```

Ex√©cutons-le plusieurs fois, juste pour voir les diff√©rentes moyennes (avec un million de jets √† chaque fois)¬†:

```
/var/www/dice_roller $ for i in {1..10}; do php roll.php; done
11.998764
11.997870
12.003618
12.000348
11.999262
11.998068
11.993424
12.000720
12.003618
12.000378
```

Nous voyons bien que la moyenne des r√©sultats totaux tourne toujours autour de 12, mais n'est jamais _√©gale_ √† 12.<br>
Nous ne pouvons donc m√™me pas faire un grand nombre de jets et calculer la moyenne... Ou alors, il faudrait le faire, mais consid√©rer qu'avec un grand nombre de jets vient aussi une petite marge d'erreur sur la moyenne.

Nous avons donc une "solution", mais celle-ci reste approximative.

## Deuxi√®me proposition¬†: surcharger `random_int()`

Merci PHP¬†! Une fois de plus¬†!

Gr√¢ce √† PHP, il existe plusieurs fa√ßons de pouvoir surcharger une fonction native. Il existait il y a longtemps la fonction `override_function()` mais faisant partie de l'extension APD (Advanced PHP Debugger) qui est abandonn√©e depuis‚Ä¶ 2004.

La meilleure fa√ßon c'est la **surcharge dans l'espace de noms**.

En effet, lorsque votre code est situ√© dans un espace de nom, et que vous ex√©cutez une fonction (n'importe laquelle), PHP va d'abord v√©rifier si celle-ci existe dans l'espace de noms actuel, et sinon, va se replier sur l'espace de noms global.

Cette surcharge est d'ailleurs celle op√©r√©e par les classes `DnsMock` et `ClockMock` du PHPUnit Bridge de Symfony pour permettre de surcharger les fonctions natives de recherche d'enregistrements DNS ou de date/temps.

Voici comment proc√©der¬†:

Dans votre classe de test `DiceRollerTest`, vous avez la possibilit√© de d√©clarer un espace de noms suppl√©mentaire, quel qu'il soit.

L'espace de noms √† rajouter **doit √™tre le m√™me que celui du `DiceRoller`**, car c'est lui qui ex√©cute la fonction native √† surcharger.

```php

namespace Tests\App;

use App\DiceRoller;
use PHPUnit\Framework\TestCase;

class DiceRollerTest extends TestCase
{
    // ...
}

namespace App;

// Function override
function random_int() { /* */ }
```

Et voil√†¬†! Avec cette m√©thode, lorsque le `DiceRoller` ex√©cutera la fonction `random_int()`, PHP cherchera d'abord √† savoir si elle a √©t√© d√©clar√©e dans le namespace de celui-ci (`App` dans notre cas), et ex√©cutera la fonction que vous avez cr√©√©e¬†!

De cette fa√ßon, vous pouvez, par exemple, ex√©cuter une fonction d'une classe statique qui vous permettrait de d√©finir d√®s le d√©part un r√©sultat √† avoir¬†:

```php

namespace Tests\App;

use App\DiceRoller;
use PHPUnit\Framework\TestCase;

class DiceRollerTest extends TestCase
{
    public static int $forcedResult = 0;

    public function test(): void
    {
        $diceRoller = new DiceRoller();

        self::$forcedResult = 1;

        $result = $diceRoller->roll(2, 6, 3);

        static::assertSame(5, $result); // Yay!
    }
    // ...
}

namespace App;

use Tests\App\DiceRollerTest;

// Function override
function random_int(int $min, int $max): int {
    return DiceRollerTest::$forcedResult;
}
```

Cette solution fonctionne bien, mais elle a un inconv√©nient¬†: si un jour le code du `DiceRoller` change et que l'appel √† `random_int()` est fait sous la forme `\random_int()`, c'est fini¬†! En effet, cette syntaxe va forcer PHP √† utiliser uniquement la fonction native, et vous ne pourrez plus jamais surcharger `random_int()`‚Ä¶

Mais ne vous en faites pas, j'ai la solution¬†!

## Troisi√®me solution¬†: l'ultime solution¬†!

La notion "d'al√©atoire" comme vous l'avez vu plus haut (et si vous connaissez les probl√©matiques li√©es au concept m√™me "d'al√©atoire dans l'informatique") est assez particuli√®re. C'est comme la r√©cup√©ration de la date, ou du cours de la bourse¬†: √ßa n'est pas 100% pr√©dictible sans avoir une sorte de "syst√®me externe".

Les g√©n√©rateurs al√©atoires utilisent tout un tas de techniques, des sortes de _hacks_, pour vous permettre d'obtenir un nombre qui _semble_ al√©atoire.

En r√©alit√©, **un g√©n√©rateur de nombres al√©atoires est un service tiers**.

Vous me voyez venir¬†?

Et oui¬†: le `DiceRoller` peut tr√®s bien fonctionner **sans `random_int()`**¬†! Par contre il ne peut pas fonctionner sans **g√©n√©rateur de nombres al√©atoires**.

Nous allons donc commencer par cr√©er une interface pour repr√©senter notre besoin, qui est assez simple pour notre probl√©matique¬†:

```php
namespace App;

interface RandomIntProviderInterface
{
    public function randomInt(int $min, int $max): int;
}
```

Il nous faudra √©videmment changer le code de notre `DiceRoller`¬†:

```php
namespace App;

class DiceRoller
{
    private RandomIntProviderInterface $randomIntProvider;

    public function __construct(RandomIntProviderInterface $randomIntProvider)
    {
        $this->randomIntProvider = $randomIntProvider;
    }

    public function roll(int $sides, int $multiplier = 1, int $offset = 0): int
    {
        return $this->randomIntProvider->randomInt(1, $sides) * $multiplier + $offset;
    }
}
```

(Notez avec quelle subtilit√© j'ai utilis√© une propri√©t√© typ√©e, merci PHP 7.4¬†!)

Excellent¬†!

Il n'y a plus qu'√† cr√©er deux classes, l'une pour l'application dans son "comportement normal"¬†:

```php
class NativeRandomIntProvider implements RandomIntProviderInterface
{
    public function randomInt(int $min, int $max): int
    {
        return \random_int($min, $max);
    }
}
```

Cette classe sera inject√©e dans le constructeur du `DiceRoller` avec votre syst√®me d'Injection de D√©pendances pr√©f√©r√© (√† tout hasard, celui de Symfony).

Ensuite, dans le cadre de nos tests, nous allons cr√©er une autre impl√©mentation¬†:

```php
class DeterministicRandomIntProvider implements RandomIntProviderInterface
{
    public int $determinedResult = 0;

    public function randomInt(int $min, int $max): int
    {
        return $this->determinedResult;
    }
}
```

Parfait¬†!

Voici donc √† quoi pourra ressembler notre test pour la classe `DiceRoller`¬†:

```php
class DiceRollerTest extends TestCase
{
    public function test¬†dice¬†roller¬†result¬†is¬†in¬†dice¬†range(int $sides, int $multiplier, int $offset): void
    {
        $randomIntProvider = new DeterministicRandomIntProvider();

        $diceRoller = new DiceRoller($randomIntProvider);

        $randomIntProvider->determinedResult = 1;

        $result = $diceRoller->roll(2, 6, 3);

        static::assertSame(5, $result); // Yay!
    }
}
```

Parfait¬†! Nous pouvons d√©sormais forcer le fournisseur de nombre "al√©atoire" √† renvoyer un nombre pr√©cis, et de cette fa√ßon, nous avons un contr√¥le total sur notre architecture pour pouvoir la tester¬†!

## Conclusion

La g√©n√©ration de donn√©es non-d√©terministes (dates, nombres al√©atoires, identifiants uniques, cl√©s secr√®tes‚Ä¶) est un vrai challenge pour les personnes qui d√©veloppent ces outils.

Ne pouvant avoir le contr√¥le sur ces syst√®mes tr√®s avanc√©s utilisant parfois de la cryptographie tr√®s pouss√©e ou carr√©ment des donn√©es compl√®tement farfelues comme les fluctuations du climat, de la [cryptographie quantique](https://fr.wikipedia.org/wiki/Cryptographie_quantique) ou m√™me des [lampes √† lave](https://www.zdnet.com/article/how-lava-lamps-are-used-to-encrypt-the-internet/), nous devons souvent (toujours¬†?) g√©rer une multitude de r√©sultats possibles par nous-m√™mes.

Partir du principe qu'une donn√©e non-d√©terministe est une **donn√©e venant d'un service tiers** nous permet de mieux structurer notre code et de le rendre plus flexible mais √©galement adaptable √† une version d√©terministe plut√¥t qu'al√©atoire de cette information tierce.

Il existe par exemple la biblioth√®que [`nesbot/carbon`](https://github.com/briannesbitt/Carbon), permettant de consid√©rer la date et le temps comme des donn√©es venant d'un service externe, et ce service nous permet donc de "falsifier" cette date, pour nos besoins personnels (comparaison de date, passage du temps "fictif" durant un seul et unique test, etc.).

{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('build/images/avent/alex-rock-ancelet.jpg') }}" alt="Alex Rock" />
{% endblock %}

{% block article_bio %}
    <h3><a href="{% block author_url %}https://twitter.com/pierstoval{% endblock %}" target="_blank">{% block article_author %}Alex Rock Ancelet{% endblock %}</a></h3>
    <p>
        Alex travaille en tant que formateur &amp; d√©veloppeur chez SensioLabs, et est √©galement lead tech pour le studio Agate, √©diteur de jeux de r√¥le.<br>
        Il a commenc√© la programmation tr√®s jeune, mais ne l'a gard√©e que comme loisir, a appris seul sans √©tudes ni formation sp√©cifique, mais a un go√ªt prononc√© pour le partage et la transmission de connaissances.
    </p>
{% endblock %}
