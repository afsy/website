{% extends 'Avent/day.html.twig' %}

{% set year = 2019 %}

{% block article_title "Jour 12 - Workflow as Middleware" %}

{% block article_content_md %}
# D√©velopper votre application autour du composant Workflow

Le composant **Workflow** est aujourd‚Äôhui assez peu connu malgr√© son utilit√© non n√©gligeable. Dans cet article nous allons voir comment vous pouvez l‚Äôutiliser dans vos projets pour g√©rer le cycle de vie d‚Äôun objet et le customiser pour l‚Äôutiliser comme un moyen d‚Äôappliquer des **middlewares**.

Un middleware, c‚Äôest un service ind√©pendant qui va, souvent avec d‚Äôautres middlewares, permettre d‚Äôeffectuer une action. Par exemple on pourra avoir un middleware pour g√©n√©rer une facture, puis un pour g√©n√©rer un PDF. Chacun des deux sont ind√©pendants et nous pourrons r√©utiliser le middleware PDF si nous avons √† g√©n√©rer d‚Äôautres PDF !

## Symfony Workflow

### C‚Äôest quoi ?

Le composant **workflow** permet de d√©finir le **cycle de vie** d'un objet.
Chaque √©tape du processus est appel√©e une **place**.
Ce cycle passe d'une (ou plusieurs) place(s) √† une autre (ou des autres) place(s) via une **transition**.
Pour passer une transition, il faut que votre objet soit dans **toutes** les places en amont.

Par exemple, la gestion d‚Äôune commande de son √©tat de panier √† sa livraison ne se fait pas en un clin d‚Äôoeil. L'objet commande transite dans plusieurs √©tats qui ont chacun des impacts sur ses propri√©t√©s.

### Dans une config YAML

Pour mettre en place un workflow, il faut cr√©er un fichier de configuration `config/packages/workflow.yaml`.
Par exemple, le cycle de vie d‚Äôune pull request est repr√©sent√© ici :

```yaml
workflow:
    workflows:
        pull_request:
            type: 'state_machine'
            marking_store:
                type: 'method'
                property: 'currentPlace'
            supports:
                - App\Entity\PullRequest
            initial_marking: opened
            places: [opened, closed, needs_review, reviewed, merged]
            transitions:
                feedback:
                    from: opened
                    to:   needs_review
                review:
                    from: [opened, needs_review]
                    to:   reviewed
                merge:
                    from: reviewed
                    to:   merged
                close:
                    from: [opened, needs_review, reviewed]
                    to:   closed
```

### Sch√©ma

Le composant Workflow fournit plusieurs moyens de visualiser les workflows que vous avez configur√© : Graphiviz ou PlantUML.

Par exemple, pour exporter votre workflow au format Graphiviz et obtenir un svg, vous devez ex√©cuter la commande suivante en rempla√ßant "pull_request" par le nom de votre workflow :

```bash
php bin/console workflow:dump pull_request | dot -Tsvg -o graph.svg
```

Vous pouvez retrouver [les autres moyens d‚Äôexporter](https://symfony.com/doc/current/workflow/dumping-workflows.html) votre workflow sur la documentation Symfony. Et vous obtiendrez un sch√©ma comme ici :

![schema]({{ asset('build/avent/2019/12/workflow-schema.svg') }})

## Workflow as Middleware

Pour compl√©ter notre Workflow orient√© middleware, il nous manque deux choses :
- Subscriber : permet de d√©clencher vos actions lorsqu'une transition passe ;
- Action(s) : permet le lien entre votre transition et vos services.

### Votre YAML, avec des actions

Pour √ßa, nous allons tout d‚Äôabord ajouter un moyen de d√©crire les actions qui seront ex√©cut√©s lors des transitions.

```yaml
workflow:
    workflows:
        pull_request:
            places:
                # ...
            metadata:
                actions:
                    - 'App\Workflow\Action\Notification'
            transitions:
                merge:
                    from: reviewed
                    to:   merged
                    metadata:
                        actions:
                            - 'Workflow\Action\PullRequest\Merge'
                # ...
```

Ici nous ajoutons deux cl√©s `metadata` :
- Une premi√®re √† la racine du workflow, cela va nous permettre d‚Äôavoir des actions communes √† toutes les transitions ;
- Et une autre au niveau de la transition pour avoir des actions li√©s √† la transition uniquement.

### Action

Maintenant, il nous faut des actions √† ex√©cuter ! Ces actions repr√©sentent votre logique m√©tier. L‚Äôid√©e est de bien s√©parer vos actions pour pouvoir les r√©utiliser quand c‚Äôest possible.

#### Interface

Nous commen√ßons par d√©finir une interface simple, pour nous permettre de d√©crire la m√©thode qui sera utilis√©e ensuite dans notre Subscriber :

```php
interface ActionTransitionInterface
{
    public function transition(object $entity, Transition $transition): void;
}
```

#### Configuration

Gr√¢ce √† cette interface, nous pouvons appliquer un tag dans l‚Äôinjection de d√©pendance pour identifier toutes les actions de Workflow gr√¢ce √† la configuration suivante :

```yaml
_instanceof:
    Workflow\Action\ActionTransitionInterface:
        tags: ['workflow.action']
```

Avec cette configuration, vous pourrez r√©cup√©rer tous les services qui ont cette interface gr√¢ce au tag `workflow.action`.

#### Impl√©mentation

Voici quelques exemples d‚Äôactions que vous pouvez impl√©menter.
La premi√®re est un exemple d‚Äôaction pour ex√©cuter un code m√©tier :

```php
class Merge implements ActionTransitionInterface
{
    public function transition(object $entity, Transition $transition)
    {
        // ma logique ici üëã
    }
}
```

Et ici nous pouvons voir une action plus g√©n√©rique pour notifier le changement de statut de notre pull request :

```php
class Notification implements ActionTransitionInterface
{
    private $notifier;

    public function __construct(NotifierInterface $notifier)
    {
        $this->notifier = $notifier;
    }

    public function transition(object $entity, Transition $transition)
    {
        $notification = new Notification(sprintf(‚ÄòStatus updated: %s‚Äô, $transition->getName), [‚Äòemail‚Äô, ‚Äòchat/slack‚Äô]);
        $this->notifier->send($notification, new Receiver(‚Äòfoo@jolicode.com‚Äô));
    }
}
```

### Subscriber

Ensuite nous allons faire un Subscriber qui ex√©cutera une m√©thode `handleTransition` pour chaque √©v√®nement `workflow.completed` avec le contenu suivant :

```php
public function handleTransition(TransitionEvent $event)
{
    $subject = $event->getSubject();
    $transition = $event->getTransition();
    $store = $event->getWorkflow()->getMetadataStore();

    $actions = array_merge(
        $store->getMetadata('actions', $transition) ?? [],
        $store->getMetadata('actions') ?? []
    );

    foreach ($actions as $action) {
        if ($this->actions->has($action)) {
            $actionObject = $this->actions->get($action);
            $actionObject->transition($subject, $transition));
        }
    }
}
```

Ici nous allons collecter les actions √† ex√©cuter, tel que nous les avons d√©finis dans le fichier YAML. Les actions de la transition passeront en premier ensuite les actions "g√©n√©rales" au Workflow.
Puis nous ex√©cutons les actions une par une ! üëå

#### Configuration

Pour finir notre Subscriber, un peu de configuration ! Dans votre d√©claration de services, vous aurez √† ajouter le code suivant :

```yaml
Workflow\Subscriber\WorkflowSubscriber:
    arguments:
        $actions: !tagged_locator
                    tag: workflow.action
```

On va r√©cup√©rer toutes les actions gr√¢ce aux tags `workflow.action` d√©fini dans l‚Äôinjection de d√©pendances plus t√¥t. Et ensuite, voici √† quoi ressemble notre constructeur pour g√©rer les actions :

```php
public function __construct(ServiceLocator $actions, ValidatorInterface $validator)
{
    $this->actions = $actions;
    $this->validator = $validator;
}
```

## Aller plus loin ‚Ä¶

Cet article pr√©sente un rapide aper√ßu de ce que vous pouvez faire avec une utilisation avanc√©e du composant Workflow, mais certaines autres choses peuvent √™tre faites pour compl√©ter votre utilisation.

### Endpoint API Platform

Dans certains projets, nous utilisons API Platform pour nous permettre d‚Äôavoir des API de fa√ßon rapide et efficace. Nous pouvons mettre en place une configuration dans API Platform pour utiliser le syst√®me de Workflow mis en place plus t√¥t.

#### Votre ressource API Platform

Tout d‚Äôabord il vous faudra une ressource, celle-ci vous permettra de d√©finir un endpoint pour actionner vos transitions et vous pourrez lui passer librement un objet (ou non) pour d√©crire votre transition :

```yaml
resources:
    Entity\PullRequest:
        itemOperations:
            transition:
                method: 'PUT'
                path: '/workflow/pull-request/{id}/{transition}'
                controller: 'App\Controller\PullRequestTransition'
                defaults:
                    _api_receive: false
                    _api_persist: false
```

Plusieurs choses √† noter :
- Dans le path d√©fini, on retrouve un `id` qui corresponds √† l‚Äôidentifiant en base de donn√©e de l‚Äôobjet sur lequel on applique la transition et une `transition` qui corresponds √† la transition √† passer dans votre Workflow ;
- On d√©sactive les events "receive" et "persist" de API Platform, en effet la deserialization sera g√©r√© dans notre controller custom et le persist dans nos actions de Workflow.

#### Votre controller ?

Derri√®re cette configuration vous aurez un controller custom qui va r√©cup√©rer votre objet, la transition a passer et indiquer quel contexte de donn√©e est √† utiliser :

```php
class PullRequestTransition extends WorkflowController
{
    public function __invoke(Request $request, PullRequest $pullRequest, string $transitionName)
    {
        return $this->applyTransition(
            $pullRequest,
            $transitionName,
            $request,
            PullRequestTransitionData::class
        );
    }
}
```

Ici, on a abstrait le passage de transition de workflow, pour passer une transition nous avons besoin de deux √©l√©ments :
- Un objet associ√© √† un Workflow ;
- Une transition √† passer ;
- Et dans le cas d‚Äôun contexte associ√© √† votre transition, vous devrez ajouter :
- La requ√™te envoy√©e √† votre application ;
- La classe de l‚Äôobjet a d√©serializer.

Ici on indique un contexte li√© `PullRequestTransitionData`, cela nous permettra de le d√©serializer et de l‚Äôexploiter dans nos actions ensuite.

L‚Äôabstraction contient alors le code suivant:

```php
public function applyTransition(object $entity, string $transitionName, Request $request = null, string $dataClass = null): WorkflowStoreInterface
{
    $workflow = $this->workflows->get($entity);

    if (!$workflow->can($entity, $transition)) {
        throw new BadRequestHttpException('transition_failed');
    }

    if (null !== $dataClass) {
        try {
            $transitionData = $this->serializer->deserialize($request->getContent() ?: '{}', $dataClass, 'json');
        } catch (NotEncodableValueException $e) {
            throw new BadRequestHttpException(‚ÄôInvalid JSON‚Äô, $e);
        }
        $workflow->apply($entity, ['data' => $transitionData]);
    } else {
        $workflow->apply($entity);
    }
}
```

Avec ce code, nous pourrons alors passer nos transitions dans notre API üéâ

#### Validation

Avant de lancer toutes ces actions, un peu de validation n‚Äôest jamais de trop !
Pour cela nous utilisons [le composant Validation de Symfony](https://symfony.com/doc/current/validation.html). Pour certaines transitions nous avons parfois un objet associ√© qui nous permet d‚Äôapporter du contexte √† la transition, par exemple un commentaire qui aurait √©t√© ajout√© √† une PR aurait un objet avec un auteur et le contenu du commentaire. Nous cr√©ons un DTO avec des contraintes de validation comme suivant :

```php
class PullRequestReviewData implements TransitionDataInterface
{
    /**
    * @Assert\NotBlank
    * @Assert\Type(‚Äústring‚Äù)
    */
    public $author;

    /**
    * @Assert\Type(‚Äústring‚Äù)
    */
    public $comment;
}
```

Ici on impl√©mente l‚Äôinterface `TransitionDataInterface`, cela nous sert uniquement pour trier les objets concernant les transitions de Workflow. Vous pouvez retrouver comment utiliser des contraintes sur vos objets dans la [documentation Symfony du composant Validation](https://symfony.com/doc/current/validation.html).

Et ensuite, dans votre controller, avec le code suivant, il pourra r√©cup√©rer votre objet et le valider avant qu‚Äôil soit pass√© √† vos actions :

```php
if ($transitionData instanceof TransitionDataInterface) {
    $violations = $this->validator->validate($data, null, $transition->getName());
    if ($violations->count() > 0) {
        throw new ValidationException($violations);
    }
}
```

### Audit trail

Nous avons souvent besoin de logguer les actions effectu√©s dans notre application. Gr√¢ce au workflow nous pouvons logguer chacune des transitions dans un Listener.

Ici je vous pr√©sente un exemple de log en base de donn√©es mais celui-ci peut-√™tre aussi effectu√© dans un fichier de log classique (via Monolog par exemple).

```php
private function transitionHistory(Event $event)
{
    $subject = $event->getSubject();

    $entry = new TransitionEntry();
    $entry->setWorkflow($event->getWorkflow()->getName());
    $entry->setSubject($workflowSubject);
    $entry->setClass(\get_class($workflowSubject));
    $entry->setReference($workflowSubject->getId() ?? 0);
    $entry->setTransition($event->getTransition()->getName());
    $entry->setAdmin('system');
    $entry->setDate(new \DateTime());

    $this->entityManager->persist($entry);
}
```

Apr√®s si vous voulez logguer uniquement certaines transitions, vous pouvez faire une action de log et l‚Äôappliquer sur les transitions que vous souhaitez logger.

## Conclusion

Gr√¢ce au composant Workflow et pattern Middleware, nous pouvons avoir des actions simples, r√©utilisables et testables unitairement !

Pour conclure, voici un exemple de Workflow appliqu√© √† de la facturation :

```yaml
workflow:
    workflows:
        order:
            metadata:
                actions:
                    - 'Workflow\Action\Doctrine\Flush'
            transitions:
                pay:
                    from: [with_billing, with_shipping, with_user]
                    to:   paid
                    metadata:
                        actions:
                            - 'Workflow\Action\Order\DoPayment'
                            - 'Workflow\Action\Order\IsPreorder'
                            - 'Workflow\Action\Order\IsFirstOrder'
                            - 'Workflow\Action\Order\Invoice\Create'
                            - 'Workflow\Action\Order\Invoice\Pdf'
                            - 'Workflow\Action\Order\SendValidationEmail'
```
{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('build/avent/baptiste-leduc.jpg') }}"  alt="Baptiste Leduc"/>
{% endblock %}

{% block article_bio %}
    <h2><a href="{% block author_url 'https://twitter.com/Korbeil_/' %}">{% block article_author 'Baptiste Leduc' %}</a></h2>
    <p>Baptiste est Consultant Web chez <a href="https://jolicode.com" target="_blank" rel="noopener noreferrer">JoliCode</a>.</p>
{% endblock %}
