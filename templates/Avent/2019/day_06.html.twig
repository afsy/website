{% extends 'Avent/day.html.twig' %}

{% set year = 2019 %}

{% block article_title "Jour 06 - PHP Asynchrone" %}

{% block article_content_md %}
PHP Asynchrone
==============

Ces derni√®res ann√©es c'est presque devenu un buzzword. Au point que certains ne veulent plus en entendre parler,
d'autres disent que √ßa n'est pas utile en PHP. D'autres encore jurent que √ßa n'existe pas et que √ßa n'est que fantasme.
Et certains d'entre nous [ne comprennent pas](https://github.com/Nekland/Woketo/issues/151#issuecomment-535016104) que √ßa
ne soit pas un fonctionnement identique √† JavaScript au point que certaines librairies
[trichent](https://github.com/ratchetphp/Pawl/blob/de50955093d3b96c4b8344b0fd065905e4c00143/src/functions.php#L26)
pour simuler un comportement similaire (elles n'en restent pas moins asynchrones r√©ellement).


Qu'est-ce que c'est l'asynchrone ?
----------------------------------

L'asynchrone c'est la capacit√© √† ne pas attendre la fin de l'ex√©cution d'une action avant de continuer l'ex√©cution du
code. Lorsque l'on parle d'asynchrone on ne parle usuellement pas de thread. PHP (au m√™me titre que JavaScript) est
monothread√© par d√©faut. Nous ne parlons pas d'ex√©cution en concurrence mais simplement d'un ordre d'ex√©cution
permettant d'√©viter les temps d'attente du programme.

Dans la r√©alit√©, vous √™tes rarement en train d'attendre. Voici les temps d'attente que vous pourriez avoir :
- Temps d'attente r√©seau (lenteur du r√©seau ou attente de traitement distant)
- Attente de l'arr√™t d'un processus enfant
- Attente du syst√®me de fichiers de votre serveur (cas √† la marge, le syst√®me de fichier est g√©n√©ralement consid√©r√© assez
  rapide pour ne pas √™tre utilis√© de fa√ßon asynchrone)

Cependant, cette capacit√© √† traiter plusieurs t√¢ches en parall√®le peut nous amener √† traiter de nouveaux sujets, tels
que notamment le multiplexing. (la capacit√© d'ouvrir plusieurs flux r√©seau en m√™me temps pour transf√©rer les donn√©es
potentiellement plus rapidement)

Mais alors comment fonctionne l'asynchrone en PHP ? Et bien comme dans la plupart des langages. Nous lan√ßons des
instructions syst√®me, continuons, et reprenons leur r√©sultat plus tard. Un cas d'exemple typique et tr√®s simple est possible
avec le [ProcessComponent](https://symfony.com/doc/current/components/process.html) de Symfony :

```php
<?php
// slow_process.php

echo "Starting process\n";
sleep(10);
echo "Important message\n";
sleep(10);
echo "Process is finished\n";
```

```php
<?php
// mon_script_asynchrone.php
require 'vendor/autoload.php';

$process = new \Symfony\Component\Process\Process(['php', 'slow_process.php']);
$process->start();

echo "Un peu de travail pour PHP pendant que notre processus enfant s'ex√©cute...\n";

$process->wait();

echo "Fin du runner\n";
```

Mais si l'asynchrone est aussi simple, pourquoi est-ce que tout le monde en parle ? On en parle parce qu'en 2019, nous
recherchons tous le code le plus rapide, et parfois nous allons vouloir utiliser beaucoup d'appels asynchrones pour
y arriver. Dans l'exemple pr√©c√©dent nous avons vu une t√¢che asynchrone, ce code √©tait simple √† l'extr√™me. Mais il ne
r√©sout pas un probl√®me aussi simple que v√©rifier l'output du processus 10 secondes apr√®s le lancement ! Le lancement
et la gestion de plusieurs t√¢ches asynchrones est √©galement en option.

Je vais vous pr√©senter deux solutions qui permettent de rendre votre code asynchrone. Les event-loop et les g√©n√©rateurs.

Les event-loops
---------------

Avant que les g√©n√©rateurs ne soient impl√©ment√©s dans PHP, c'√©tait la solution privil√©gi√©e. Pour illustrer cela nous
allons √©crire un serveur web. C'est l'exemple le plus typique qui n√©cessite absolument de l'asynchrone, et pour cause :
sans asynchronisme, notre serveur ne pourra pas accepter plus d'une connexion !

### √âcrivons un serveur web simple non-asynchrone

```php
<?php

$port = 1337;
$server = stream_socket_server(
    'tcp://127.0.0.1:' . $port, $errno, $errstr, STREAM_SERVER_BIND|STREAM_SERVER_LISTEN
);

echo "Listening on port $port\n";


// Cette simulation est affreusement fausse: un sleep ordonne √† votre programme de se mettre en pause compl√®te
// ce qui veut dire qu'il ne peut pas y avoir de processus asynchrone en parall√®le !... C'est pour l'exemple.
function someProcess()
{
    echo "Processing\n";
    sleep(2); // D√©laie l'ex√©cution suivante de 2 secondes
    echo "Processing again\n";
    sleep(2); // D√©laie l'ex√©cution suivante de 2 secondes
    echo "Processing again again\n";
    sleep(2); // D√©laie l'ex√©cution suivante de 2 secondes
    echo "Finished my stuff\n";
}

while($client = stream_socket_accept($server)) {
    $buffer = '';

    if($client) {
        // On attend d'avoir une requ√™te http compl√®te
        while( !preg_match('/\r?\n\r?\n/', $buffer) )
            $buffer .= fread($client, 2046);

        // Voici notre HTML de r√©ponse
        $response = "<h1>Reponse synchrone</h1>\n" . time();

        // On encapsule ce HTML dans une requ√™te HTTP valide
        fwrite($client,"HTTP/1.1 200 OK\r\n" .
        "Date: " . gmdate('D, d M Y H:i:s T') . "\r\n" .
        "Connection: close\r\n" .
        "Content-Type: text/html\r\n" .
        "Content-Length: ". strlen($response). "\r\n" .
        "\r\n" .
        $response . "\r\n");

        // On termine et on attend une autre connexion !
        fclose($client);

        // Processing something
        someProcess();
    }
}
```
Cet exemple illustre le probl√®me : nous n'avons pas de concurrence. Vous pouvez lancer ce programme et utiliser votre
navigateur pour le prouver ! La 2√®me page mettra bien 6 secondes √† s'afficher, pendant que votre terminal affichera
notre faux traitement.

Et pourtant les fonctions `stream_set_blocking` et `stream_socket_accept` ont des arguments qui nous permettent d'ouvrir
plusieurs connexions simultan√©ment.

### Passons maintenant √† l'asynchrone !

Pour faire notre event-loop, nous allons utiliser un m√©canisme bien connu de PHP: la [fonction](https://www.php.net/manual/fr/function.stream-select.php)
`stream_select`. Le r√¥le de cette fonction est de mettre en pause le programme jusqu'√† ce qu'un des streams qu'on
lui passe en param√®tre soit actif.

Il ne reste plus qu'√† √©crire une classe qui encapsule ce fonctionnement avec plusieurs streams ! Et dans l'id√©e c'est
tr√®s simple, nous voulons une classe qui g√®re les choses suivantes :
- Plusieurs streams (en √©criture et lecture)
- Une boucle infinie pour que notre programme ne s'arr√™te pas
- Un temps d'attente en cas d'inactivit√© (gr√¢ce √† `stream_select()`)

Voici une impl√©mentation possible :
```php
class Loop
{
    private $running;
    private $readStreams;
    private $readHandlers;
    private $writeStreams;
    private $writeHandlers;

    public function __construct()
    {
        $this->readStreams = [];
        $this->readHandlers = [];
        $this->writeStreams = [];
        $this->writeHandlers = [];
        $this->running = false;
    }

    public function addReadStream($stream, $onActivity)
    {
        // stream et handler ont la m√™me cl√©
        $this->readStreams[] = $stream;
        $this->readHandlers[] = $onActivity;
    }

    public function addWriteStream($stream, $onActivity)
    {
        $this->writeStreams[] = $stream;
        $this->writeHandlers[] = $onActivity;
    }

    public function run()
    {
        $this->running = true;
        while ($this->running) {
            // Encore une fois on fait des temps d'attente pour pas que le processeur explose
            $this->waitForActivity();
        }
    }

    private function waitForActivity()
    {
        // stream_select va utiliser ces variables et remplacer leur contenu par les streams actifs
        $read = $this->readStreams;
        $write = $this->writeStreams;

        $available = @stream_select($read, $write, $except, null);

        if (false === $available) {
            return;
        }

        foreach ($read as $key => $readStream) {
            if (isset($this->readHandlers[$key])) {
                \call_user_func($this->readHandlers[$key], $readStream);
            }
        }
        foreach ($write as $key => $writeStream) {
            if (isset($this->writeHandlers[$key])) {
                \call_user_func($this->writeHandlers[$key], $writeStream);
            }
        }
    }
}
```

Et √† l'utilisation cela donnerait quelque chose comme ceci en reprenant le code pr√©c√©dent. Faisons une petite folie :
ouvrons deux serveurs en m√™me temps pour prouver que nous sommes bel et bien asynchrones !

```php
$loop = new Loop();

// Notre serveur, mais r√©√©crit avec la boucle
$server = stream_socket_server('tcp://127.0.0.1:1337');
stream_set_blocking($server, false); // Le mode non bloquant activ√© !

$loop->addReadStream($server, function ($server) use ($loop) {
    $client = stream_socket_accept($server);
    $loop->addWriteStream($client, function ($client) {
        $response = "<h1>Reponse asynchrone</h1>\n" . time();

        fwrite($client,"HTTP/1.1 200 OK\r\n" .
            "Date: " . gmdate('D, d M Y H:i:s T') . "\r\n" .
            "Connection: close\r\n" .
            "Content-Type: text/html\r\n" .
            "Content-Length: ". strlen($response). "\r\n" .
            "\r\n" .
            $response . "\r\n");
        fclose($client);
    });
});

// Soyons fous, cr√©ons deux serveurs !
$server2 = stream_socket_server('tcp://127.0.0.1:8000');
stream_set_blocking($server2, false);
$loop->addReadStream($server2, function ($server) use ($loop) {
    $client = stream_socket_accept($server);
    $loop->addWriteStream($client, function ($client) {
        $response = "<h1>Reponse asynchrone 2</h1>\n" . time();

        fwrite($client,"HTTP/1.1 200 OK\r\n" .
            "Date: " . gmdate('D, d M Y H:i:s T') . "\r\n" .
            "Connection: close\r\n" .
            "Content-Type: text/html\r\n" .
            "Content-Length: ". strlen($response). "\r\n" .
            "\r\n" .
            $response . "\r\n");
        fclose($client);
    });
});

$loop->run();
```

On pourrait imaginer des tas de fonctionnalit√©s suppl√©mentaires √† cette event-loop parmi lesquelles :
- Une m√©thode stop pour arr√™ter la boucle
- La possibilit√© de supprimer les streams (ceux ferm√©s devraient √™tre supprim√©s)
- La gestion de signaux
- La possibilit√© d'avoir des timers

üí°Tiens d'ailleurs, nous avons deux serveurs capables de r√©pondre √† des clients de fa√ßons asynchrone... Mais nous n'avons
pas r√©solu notre probl√®me initial ! Comment faire des timeouts dans cette situation ?!

Pour r√©soudre ce probl√®me on peut utiliser le timeout de la fonction `stream_select()` afin d'attendre juste le temps
n√©cessaire. Le cas d'un grand nombre de timers demande d'ajouter pas mal de code, pour faire simple on ne va g√©rer qu'un
seul timer mais vous comprendrez l'id√©e.

```php
// Notre loop (simplifi√©e, mais tout le code que nous avons vu est toujours l√† !)
class Loop
{
    private $time;
    private $timeHandler;

    public function __construct()
    {
        $this->timeHandler = null;
        $this->time = null;
    }

    // Pour cet exemple on sera pr√©cis √† la seconde pr√®s, mais on peut faire mieux !
    public function setTimeout(int $timeout, callable $handler)
    {
        $this->time = time() + $timeout;
        $this->timeHandler = $handler;
    }

    public function run()
    {
        $this->running = true;
        while ($this->running) {
            $timeout = null;

            // S'il y a un timer
            if ($this->timeHandler !== null) {
                $time = time();
                // Si le timer est √† ex√©cuter
                if ($this->time <= $time) {
                    $this->executeTimeHandler();
                } else {
                    // Evitons le temps de processeur inutile, sp√©cifions un timeout √† stream_select()
                    $timeout = $this->time - $time;
                    if ($timeout <= 0) {
                        $timeout = null; // Il ne faut pas lui envoyer null sinon la fonction s'arr√™tera de suite
                    }
                }
            }
            // Encore une fois on fait des temps d'attente pour pas que le processeur explose
            $this->waitForActivity($timeout);
        }
    }

    private function executeTimeHandler()
    {
        $handler = $this->timeHandler;
        $this->timeHandler = null;
        $this->time = null;
        $handler($this);
    }

    private function waitForActivity($timeout)
    {
        // ... vous connaissez le d√©but

        // En r√©alit√© il est possible qu'il n'y ait pas de streams, il faudrait alors utiliser la fonction sleep()
        $available = @stream_select($read, $write, $except, $timeout);

        // ... vous connaissez la fin
    }
}
```

Utilisons cette nouvelle classe :

```php
$loop = new Loop();

// Notre serveur, mais r√©√©crit avec la boucle
$server = stream_socket_server('tcp://127.0.0.1:1337');
stream_set_blocking($server, false); // Le mode non bloquant activ√© !

function process(Loop $loop)
{
    echo "Processing\n";
    $loop->setTimeout(6, function () {
        echo "Finished my stuff\n";
    });
}

$loop->addReadStream($server, function ($server) use($loop) {
    $client = stream_socket_accept($server);
    $loop->addWriteStream($client, function ($client) use ($loop) {
        $response = "<h1>Reponse asynchrone</h1>\n" . time();

        fwrite($client,"HTTP/1.1 200 OK\r\n" .
            "Date: " . gmdate('D, d M Y H:i:s T') . "\r\n" .
            "Connection: close\r\n" .
            "Content-Type: text/html\r\n" .
            "Content-Length: ". strlen($response). "\r\n" .
            "\r\n" .
            $response . "\r\n");
        fclose($client);
        process($loop);
    });
});

$loop->run();
```

Affichez une page dans votre navigateur, notre timer se lance ! Et vous pouvez chronom√©trer, √ßa va prendre 6 secondes !

Ce n'√©tait pas de tout repos, mais nous avons notre PHP Asynchrone. üéâ

**Pour aller plus loin**, sachez que [react-php](https://github.com/reactphp/event-loop)
fait un tr√®s bon travail par rapport aux event-loop. Inutile de r√©-impl√©menter cela vous-m√™me. Ils ont m√™me une abstraction
qui permet d'utiliser des extensions PHP qui sont plus performantes sur ce sujet. Je vous recommande l'installation
de l'[extension](https://pecl.php.net/package/event) `ext-event`, react-php fonctionnera automatiquement avec celle-ci.
Si vous utilisez [Ratchet](https://github.com/ratchetphp/Ratchet) ou [Woketo](https://github.com/Nekland/Woketo), sachez
que ces projets bas√©s sur react-php b√©n√©ficieront automatiquement de l'extension que vous avez install√©e ! ‚ú®

Les g√©n√©rateurs
---------------

Ce m√©canisme de PHP introduit en PHP 5.5.0 permet de faire du traitement asynchrone. Ce n'est pas √©vident au premier
abord, mais sa capacit√© √† [changer le flux d'ex√©cution d'un programme](https://www.php.net/manual/fr/class.generator.php) lui
permet de faire les choses suivantes :
- Arr√™ter une boucle infinie pour traiter autre chose
- Arr√™ter une fonction
- Et m√™me revenir en arri√®re


En voici un exemple concret de [coroutine](https://en.wikipedia.org/wiki/Coroutine) qui va vous surprendre :
```php
function logger($fileName) {
    $fileHandle = fopen($fileName, 'a');
    while (true) {
        fwrite($fileHandle, yield . "\n");
    }
}

$logger = logger(__DIR__ . '/log');
$logger->send('Foo');
echo "Un traitement quelconque\n";
$logger->send('Bar');
```

Dans cet exemple, malgr√© la boucle infinie, mon echo va √™tre affich√© et le script va s'arr√™ter.

Pour mettre en place notre asynchrone avec les g√©n√©rateurs nous allons utiliser un scheduler et d√©cr√©ter que nos g√©n√©rateurs
sont des "t√¢ches". Sans √™tre r√©ellement asynchrone, cet exemple ex√©cute tout de m√™me nos deux t√¢ches de fa√ßons concurrente :

```php
class Scheduler
{
    private $tasks = [];

    public function newTask(Generator $task)
    {
        $this->tasks[] = [
            'generator' => $task,
            'isFirstIteration' => false,
        ];
    }

    public function run()
    {
        while(!empty($this->tasks)) {
            // Ex√©cution des t√¢ches en concurrence
            foreach ($this->tasks as $id => $task) {
                if ($task['isFirstIteration']) {
                    $task['generator']->current();
                    $task['isFirstIteration'] = false;
                } else {
                    // Pour l'instant envoyer des choses √† notre g√©n√©rateur ne nous int√©resse pas.
                    // Mais c'est tout de m√™me int√©ressant de voir qu'on peut le faire pour la suite.
                    $task['generator']->send('something');
                }
            }

            // Suppression des t√¢ches termin√©es
            $this->tasks = array_filter($this->tasks, function ($task) {
                return $task['generator']->valid();
            });
        }
    }
}

function task1() {
    for ($i = 1; $i <= 10; ++$i) {
        echo "This is task 1 iteration $i.\n";
        yield;
    }
}

function task2() {
    for ($i = 1; $i <= 5; ++$i) {
        echo "This is task 2 iteration $i.\n";
        yield;
    }
}

$scheduler = new Scheduler;

$scheduler->newTask(task1());
$scheduler->newTask(task2());

$scheduler->run();
```

Nous avons un d√©but d'asynchrone, en tous les cas de l'ex√©cution concurrente ! La sortie de l'ex√©cution du code
pr√©c√©dent est la suivante :

```
This is task 1 iteration 1.
This is task 1 iteration 2.
This is task 2 iteration 1.
This is task 2 iteration 2.
This is task 1 iteration 3.
This is task 2 iteration 3.
This is task 1 iteration 4.
This is task 2 iteration 4.
This is task 1 iteration 5.
This is task 2 iteration 5.
This is task 1 iteration 6.
This is task 1 iteration 7.
This is task 1 iteration 8.
This is task 1 iteration 9.
This is task 1 iteration 10.
```

Le code n√©cessaire pour produire un syst√®me asynchrone √† l'aide des g√©n√©rateurs est assez lourd. Je vous passe les
d√©tails et vous laisse simplement avec un lien gist comment√© (mais fonctionnel !).

https://gist.github.com/Nek-/ae895c30e7da22b0d8bc3e17baf25fc6

Sachez que ce type d'ex√©cution asynchrone est utilis√© par les librairies suivantes :
- [amphp](https://amphp.org/), leur √©quipe propose d'ailleurs un grand nombre de [packages](https://amphp.org/packages)
  qui permettent de dialoguer de fa√ßon asynchrone avec d'autres services.
- [Tornado](https://github.com/M6Web/Tornado), un projet qui a fait ses preuves chez M6 pour faire des requ√™tes HTTP
  en concurrence.

**Note :**
Certains exemples viennent ou sont inspir√©s de l'excellent article de [Nikita Popov](https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html)
sur le sujet. Je vous recommande d'aller lire √©galement cet article.

Usages
------

La meilleure application est probablement l'utilisation des capacit√©s asynchrones de PHP pour effectuer des **requ√™tes
en parall√®le** en les traitant une par une d√®s leur arriv√©e. L'utilisation des g√©n√©rateurs se pr√™te tr√®s bien √† cet usage.

Lors de la cr√©ation d'un **serveur de websocket** il est √©galement √©vident que vous aurez besoin de ce type de m√©canisme.

Si vous avez √† cr√©er **un bot** les syst√®mes asynchrones seront √©galement vos amis !

Cependant, ne vous y fiez pas, l'utilisation pour faire de PHP un serveur web et ainsi ex√©cuter une application PHP
de la m√™me fa√ßon qu'une application NodeJS est une mauvaise id√©e. Et ce pour les raisons suivantes :
- Le probl√®me de la gestion de la m√©moire va se poser dans une application de ce type
- Comme je l'ai expliqu√© au d√©but de cet article, vous n'utilisez pas de threads lors de l'ex√©cution asynchrone, cette
  approche n'exploite donc pas enti√®rement les capacit√©s de votre machine contrairement √† php-fpm, et c'est dommage
- Il y a un gain de performance car on √©vite en effet la recompilation des fichiers PHP, mais il s'av√®re que PHP est
  tr√®s, tr√®s tr√®s tr√®s tr√®√®√®√®√®√®s rapide √† compiler (au prix de quelques erreurs de compilation parfois manquantes),
  c'est sans compter l'ajout r√©cent de la fonctionnalit√© de preloading dans PHP 7.4
- Apr√®s tout, Amazon Lambda n'est qu'une copie (plut√¥t bof) du fonctionnement de PHP-FPM, pourquoi essayer de copier
  le fonctionnement de NodeJS alors qu'ils essaient de fonctionner comme PHP lorsqu'il s'agit de HighAvailability ?



{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('build/avent/2019/06/maxime_veber.png') }}"
         alt="Association Fran√ßaise des utilisateurs de SYmfony"/>
{% endblock %}

{% block article_bio %}
    <h2>
        <a href="{% block author_url %}https://twitter.com/Nekdev{% endblock %}" target="_blank">
            {% block article_author %}Maxime Veber{% endblock %}
        </a>
    </h2>
    <p>
        Lead developer @
        <a target="_blank" href="https://www.biig.fr">BiiG</a>.
    </p>
{% endblock %}
