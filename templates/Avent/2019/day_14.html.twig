{% extends 'Avent/day.html.twig' %}

{% set year = 2019 %}

{% block article_title "Jour 14 - Comprendre Symfony avec l'Event Dispatcher" %}

{% block article_content_md %}
Comprendre Symfony avec l'EventDispatcher
=========================================


Symfony, câ€™est un framework. Alors oui, mais aujourdâ€™hui, bien plus quâ€™un framework, câ€™est un Ã©cosystÃ¨me.
D'un point de vue humain, Symfony c'est une communautÃ©, des Ã©vÃ©nements, des contributeurs qui s'investissent sur leur temps libre.
D'un point de vue technique, ce sont des composants, des *bridges*, des bundles...

Les composants si populaires quâ€™ils sont utilisÃ©s dans de trÃ¨s nombreux [projets tout aussi populaires](https://symfony.com/projects),
Ã  tel point que cet Ã©cosystÃ¨me rayonne dans celui de PHP.

Si Symfony nâ€™Ã©tait quâ€™un framework, un gros bloc dont lequel on ne peut se dÃ©pÃªtrer, il aurait au contraire plutÃ´t fait stagner PHP,
et nâ€™aurait probablement pas eu autant de succÃ¨s. Symfony 4 / Flex a cassÃ© ce mythe et beaucoup de gens se sont remis Ã  Symfony pour lâ€™occasion.

Il peut donc Ãªtre pertinent de sâ€™attarder un peu sur ces fameux composants de temps en temps, et de saisir leur intÃ©rÃªt.
Car vous lâ€™aurez compris, Symfony repose sur ceux-ci, et si vous utilisez le framework, vous utilisez forcÃ©ment les composants.


Mais comment ces composants sont-ils intÃ©grÃ©s Ã  Symfony de maniÃ¨re aussi transparente ?
Pour comprendre cela, il faut se pencher sur deux composants qui en sont le coeur mÃªme : HttpKernel et EventDispatcher.


On va principalement sâ€™attacher Ã  comprendre EventDispatcher aujourdâ€™hui, parce quâ€™il y a beaucoup de choses Ã  dire sur cette librairie !

Pour cet article, je pars du principe que vous lâ€™avez dÃ©jÃ  utilisÃ© au moins une fois.


## Quâ€™est-ce que lâ€™EventDispatcher ? (rapidement)


Il faut retenir que câ€™est un composant qui implÃ©mente deux design patterns :
[Observer](https://refactoring.guru/design-patterns/observer) et [Mediator](https://refactoring.guru/design-patterns/mediator).


Observer : Un ou plusieurs "observeurs" sont enregistrÃ©s chez un ou plusieurs "sujets".
Lorsque quâ€™un sujet dÃ©cide que quelque chose de notable se produit, il notifie ses observers qui sont alors appelÃ©s Ã  leur tour.

Mediator : On ajoute un intermÃ©diaire entre les observeurs et les sujets, de sorte quâ€™il nâ€™y ait pas de dÃ©pendance directe entre les deux.


**ConcrÃ¨tement** :

La classe EventDispatcher est lâ€™implÃ©mentation de Mediator. Elle sâ€™occupe de mÃ©moriser les observeurs (autrement appelÃ©s Listeners).
Ceux-ci doivent Ãªtre liÃ©s Ã  un Ã©vÃ©nement (Event), qui sera Ã©mis par les sujets.
De cette maniÃ¨re, les sujets nâ€™ont plus besoin de connaÃ®tre leurs listeners, mais seulement lâ€™EventDispatcher, et c'est la responsabilitÃ© de ce dernier de les appeler.

Si je vous ne ai pas trop perdu ğŸ˜…, je vais faire un petit apartÃ© sur les Ã©vÃ©nements.
Cette notion, en dehors de PHP, elle vous est peut-Ãªtre dÃ©jÃ  familiÃ¨re : elle est au coeur de la programmation orientÃ©e Ã©vÃ¨nements, qui est lâ€™essence mÃªme de Javascript.

Une des principales fonctionnalitÃ©s intÃ©grÃ©es au coeur de Javascript est celle de pouvoir associer une fonction Ã  un Ã©lÃ©ment du DOM et Ã  un Ã©vÃ©nement,
de sorte que cette fonction soit appelÃ©e lorsque cet Ã©vÃ©nement se dÃ©clenche sur cet Ã©lÃ©ment : câ€™est `addEventListener()` !



Câ€™est bien pratique dans un contexte de page web interactive, car on ne fait quâ€™Ã©mettre des Ã©vÃ©nements dans notre page :
cliquer sur une icÃ´ne, soumettre un formulaire, passer la souris sur un lien, sont autant dâ€™Ã©vÃ©nements auxquels on peut avoir envie de rÃ©agir pour rendre la navigation plus fluide et/ou agrÃ©able.



Alors, ok pour une utilisation dans un tel contexte, mais en PHP, pourquoi donc ?

Par exemple, mettons que jâ€™ai une propriÃ©tÃ© `updated_at` sur une entitÃ© Doctrine que je veux mettre Ã  jour Ã  chaque update.
Il peut Ãªtre intÃ©ressant dâ€™utiliser ce systÃ¨me, car on nâ€™a pas forcÃ©ment envie de faire Ã§a manuellement, surtout dans un cas comme celui-ci qui est censÃ© Ãªtre une action systÃ©matique.

Avec Doctrine ORM qui apporte son systÃ¨me dâ€™Ã©vÃ©nements, je peux mettre Ã  jour cette propriÃ©tÃ© dÃ¨s que mon entitÃ© est concernÃ©e par un flush en Ã©coutant lâ€™Ã©vÃ©nement `onFlush`.
De cette maniÃ¨re, cette logique lÃ  est sÃ©parÃ©e du reste du code, et je nâ€™ai pas Ã  mâ€™en soucier Ã  chaque update !

Il y a [plusieurs maniÃ¨res de faire](https://symfony.com/doc/current/doctrine/events.html), Ã  chacun de voir ce quâ€™il prÃ©fÃ¨re.
En tout cas, Ã§a peut Ãªtre un cas dâ€™utilisation valide.


On a vu que la programmation orientÃ©e objet Ã©tait pratique en Javascript, quâ€™elle est aussi applicable en PHP,
et que lâ€™EventDispatcher peut servir Ã  appliquer cette approche Ã  notre code PHP.



Mais on a surtout vu que lâ€™intÃ©rÃªt principal de lâ€™EventDispatcher, câ€™est le dÃ©couplage du code (je rappelle quâ€™il combine deux design patterns dont câ€™est la spÃ©cialitÃ©) Ã  travers des Ã©vÃ©nements.

AprÃ¨s cette petit rappel de ce quâ€™est le composant, voyons comment il est utilisÃ© dans Symfony.


## Pourquoi un tel composant dans lâ€™Ã©cosystÃ¨me ?

Dans Symfony, EventDispatcher est utilisÃ© dans plusieurs autres composants : HttpKernel, Form, Security, Workflow...

Dans ces composants sont dÃ©finis plusieurs `events`. Si on prend le cas dâ€™HttpKernel, vous avez peut-Ãªtre dÃ©jÃ  entendu parler des Kernel Events.
Ils sont dispatchÃ©s dans la classe [HttpKernel](https://github.com/symfony/http-kernel/blob/5.0/HttpKernel.php#L115).

```php
$event = new RequestEvent($this, $request, $type);

$this->dispatcher->dispatch($event, KernelEvents::REQUEST);
// ...
$event = new ControllerEvent($this, $controller, $request, $type);
$this->dispatcher->dispatch($event, KernelEvents::CONTROLLER);

// ...

$event = new ControllerArgumentsEvent($this, $controller, $arguments, $request, $type);
$this->dispatcher->dispatch($event, KernelEvents::CONTROLLER_ARGUMENTS);

if (!$response instanceof Response) {
    $event = new ViewEvent($this, $request, $type, $response);
    $this->dispatcher->dispatch($event, KernelEvents::VIEW);
// ...
}
```
Vous venez peut-Ãªtre bien de regarder le code de la classe la plus importante de Symfony !
`HttpKernel` ne fait pas grand chose, mais dÃ©jÃ  bien assez ; il dÃ©clare le cycle de vie dâ€™une requÃªte et plusieurs points dâ€™attache en Ã©mettant (dispatch) des Ã©vÃ©nements, que nâ€™importe qui peut Ã©couter pour sâ€™y brancher.
Câ€™est de cette maniÃ¨re que les autres composants de Symfony sont liÃ©s au Kernel ! Câ€™est grÃ¢ce Ã  ce mÃ©canisme que nous pouvons avoir le framework que nous connaissons.
La requÃªte Ã  traiter est baladÃ©e Ã  travers diffÃ©rents Ã©vÃ©nements, tout comme le contrÃ´leur et la rÃ©ponse ; les diffÃ©rents composants qui y sont liÃ©s les rÃ©cupÃ¨rent et les traitent.

Prenons lâ€™exemple du *routing* de Symfony : vous-Ãªtes vous dÃ©jÃ  demandÃ© comment le routing Ã©tait appelÃ© ?
Si oui, sachez que câ€™est beaucoup moins cachÃ© quâ€™on ne pourrait le penser : tout se trouve dans [RouterListener](https://github.com/symfony/http-kernel/blob/5.0/EventListener/RouterListener.php#L97) !
On peut voir que cette classe implÃ©mente `EventSubscriberInterface` et appelle le composant Routing sur lâ€™Ã©vÃ©nement `kernel.request`.



Si vous passez un peu plus de temps dans [`Symfony\Component\HttpKernel\EventListener`](https://github.com/symfony/http-kernel/tree/5.0/EventListener), vous verrez que toutes les classes qui sâ€™y trouvent sont dâ€™autres listeners qui Ã©coutent des Ã©vÃ¨nements du Kernel ! Ce sont ces listeners qui permettent dâ€™appeler les autres composants de Symfony, sâ€™ils sont installÃ©s, pendant le parcours de la requÃªte.

Le [FrameworkBundle](https://github.com/symfony/framework-bundle), qui vient avec toute crÃ©ation dâ€™un projet Symfony, enregistre tous ces listeners dans le conteneur, et de cette maniÃ¨re ils sont bien appelÃ©s au moment oÃ¹ les Ã©vÃ©nements du Kernel sont lancÃ©s.


Je ne pourrai pas vous recommander assez assez la lecture de [cette page de doc](https://symfony.com/doc/current/components/http_kernel.html) ! Elle explique dans le dÃ©tail ce que je vous raconte.



VoilÃ  pourquoi ce composant s'appelle `HttpKernel` : câ€™est dâ€™ici que tout part !
Pour rÃ©sumer : HttpKernel utilise EventDispatcher pour Ã©mettre des *events* et dÃ©finir le cycle de vie dâ€™une requÃªte.
Des listeners Ã©coutent ces Ã©vents et appellent les autres composants Symfony.
C'est donc pour cela que vous pouvez les utiliser dans votre application de maniÃ¨re totalement transparente.

D'ailleurs n'hÃ©sitez pas Ã  jouer un peu avec HttpKernel et EventDispatcher pour essayer de vous [crÃ©er votre propre framework](https://symfony.com/doc/current/create_framework/index.html) !
Câ€™est une excellente mÃ©thode pour comprendre les choix qui ont Ã©tÃ© faits dans Symfony.

On constate donc que lâ€™utilisation du composant EventDispatcher permet en fait de rendre Symfony totalement modulaire ! Câ€™est un systÃ¨me de plugin âœ¨.

Nous avons lÃ  un cas dâ€™utilisation trÃ¨s intÃ©ressant du composant, et qu nâ€™a rien Ã  voir avec lâ€™exemple de Doctrine listener que je donnais plus haut.
EventDispatcher est utilisÃ© Ã  un autre niveau, non pas pour rÃ©agir Ã  des Ã©vÃ©nements du modÃ¨le, mais au niveau de la structure de lâ€™application en tant que telle.

## Est-ce pertinent dâ€™utiliser EventDispatcher dans mon app ?


Comme on lâ€™a vu prÃ©cÃ©demment, lâ€™avantage de lâ€™utilisation de lâ€™EventDispatcher, câ€™est de grandement dÃ©coupler sujet et listener.
Câ€™est trÃ¨s utile dans certains cas, mais dans votre app, cela ne facilite pas du tout la lisibilitÃ©, la maintenabilitÃ© et le debugâ€¦
Je parlais tout Ã  l'heure de Javascript, ceux qui en font rÃ©guliÃ¨rement le savent mieux que personne :
un petit script avec quelques listeners, Ã§a reste gÃ©rable, mais quand lâ€™application grandit on se retrouve rapidement avec un sac de noeuds.
Câ€™est en partie pour cette raison que la tendance est aux librairies qui incitent Ã  dÃ©couper ses pages en composants : on rÃ©duit le scope dans lequel on dÃ©finit nos listeners.

Je ne connais pas dâ€™IDE Ã  lâ€™heure actuelle capable de remonter les listeners Ã  partir dâ€™un *event* donnÃ©.
Par exemple, si vous voulez connaÃ®tre tous les listeners qui sont dÃ©clarÃ©s sur `kernel.request` Ã  partir du code, vous nâ€™avez pas dâ€™autre choix que de chercher cette chaine de caractÃ¨re sur lâ€™ensemble du projet.
Heureusement, il existe [une commande](https://symfony.com/doc/current/event_dispatcher.html#debugging-event-listeners) qui rÃ©pond prÃ©cisÃ©ment Ã  ce besoin :
```sh
$ php bin/console debug:event-dispatcher
```
Si vous utilisez Symfony *as a framework* vous avez aussi accÃ¨s au *profiler* qui vous liste les *listeners* appelÃ©s et non appelÃ©s sur une requÃªte donnÃ©e.
En tout cas, si jamais vous avez envie de vous lancer dans la crÃ©ation dâ€™un plugin PhpStorm, voilÃ  une idÃ©e !


Si vous avez besoin de suivre le changement dâ€™Ã©tat de vos entitÃ©s (par exemple pousser une notification quand un article passe du statut *draft* Ã  *published*),
vous pourriez Ãªtre tentÃ© dâ€™utiliser un Ã©vÃ©nement pour cela et de vous brancher dessus.
Bien sÃ»r, cela fonctionne, mais il peut Ãªtre intÃ©ressant dâ€™Ã©tudier dâ€™autres alternatives.
Il faut garder Ã  lâ€™esprit quâ€™Ã  chaque fois que lâ€™on ajoute un *listener*, on ajoute du code un peu planquÃ©.

Sachez notamment quâ€™il existe nativement les classes [\SplSubject](https://www.php.net/manual/fr/class.splsubject.php) et [\SplObserver](https://www.php.net/manual/fr/class.splobserver.php) si lâ€™envie vous prend dâ€™implÃ©menter le pattern Observer vous mÃªme.

**Quelques bonnes pratiques si toutefois vous voulez lâ€™utiliser :**

- Evitez absolument de *dispatch* un *event* dans un *listener*. Câ€™est possible, mais on amplifie encore plus ce problÃ¨me de â€œcode cachÃ©â€ en ajoutant de la profondeur.
- Les *Doctrine events* peuvent Ãªtre intÃ©ressants dans certains cas, mais il faut en user avec parcimonie.
  Ce nâ€™est en tout cas pas Ã  cet endroit que lâ€™on va ajouter de la logique mÃ©tier. Le code qui est exÃ©cutÃ© dans les listeners devrait Ãªtre court, simple et performant.
  N'hÃ©sitez pas Ã  regarder si [cette librairie](https://github.com/biig-io/DomainComponent) peut correspondre Ã  votre besoin ! Elle utilise aussi EventDispatcher, mais dans un contexte encapsulÃ©.
- Il faut aussi garder Ã  lâ€™esprit que si un listener est enregistrÃ© sur un *event*, il sera toujours exÃ©cutÃ©, donc prÃ©voir aussi une porte de sortie le plus tÃ´t possible dans le cas oÃ¹ son exÃ©cution n'est pas souhaitÃ©e.
  Typiquement dans les Doctrine Listeners, avant toute chose on commence toujours par regarder le type de l'entitÃ© passÃ©e avant de continuer.
- Les derniÃ¨res versions de Symfony vous encouragent Ã  dÃ©finir des custom *events*, ce qui Ã©vite au passage d'avoir Ã  dÃ©finir un *event name*. Plus d'infos ici : [https://symfony.com/blog/new-in-symfony-4-3-simpler-event-dispatching](https://symfony.com/blog/new-in-symfony-4-3-simpler-event-dispatching).


J'espÃ¨re vous avoir donnÃ© envie de lire un peu le code de Symfony, vous avoir fait prendre conscience qu'il est tout Ã  fait accessible, et peut-Ãªtre qu'un jour l'envie vous prendra de contribuer !
N'hÃ©sitez pas Ã  me dire dans les commentaires si quelque chose n'est pas clair.

A bientÃ´t peut-Ãªtre en meetup Sfpot !

{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('build/images/avent/remi_andrieux.jpg') }}" alt="RÃ©mi Andrieux"/>
{% endblock %}

{% block article_bio %}
    <h2>
        <a href="{% block author_url 'https://twitter.com/pimolo_' %}" target="_blank">
            {% block article_author 'RÃ©mi Andrieux' %}
        </a>
    </h2>
    <p>
        <span lang="fr">DÃ©veloppeur PHP</span> chez
        <a href="https://dental-monitoring.com/?lang=fr" target="_blank">Dental Monitoring</a>.
    </p>
{% endblock %}
