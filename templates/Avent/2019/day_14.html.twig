{% extends 'Avent/day.html.twig' %}

{% set year = 2019 %}

{% block article_title "Jour 14 - Comprendre Symfony avec l'Event Dispatcher" %}

{% block article_content_md %}
Comprendre Symfony avec l'EventDispatcher
=========================================


Symfony, c‚Äôest un framework. Alors oui, mais aujourd‚Äôhui, bien plus qu‚Äôun framework, c‚Äôest un √©cosyst√®me.
Une communaut√©, des √©v√©nements, un financement qui vivent autour et le font vivre.
Mais ce qui fait aussi le succ√®s actuel de Symfony, ce sont ses composants.

Il sont si populaires qu‚Äôils sont utilis√©s dans de tr√®s nombreux [projets tout aussi populaires](https://symfony.com/projects),
√† tel point que cet √©cosyst√®me rayonne dans celui de PHP.

Si Symfony n‚Äô√©tait qu‚Äôun framework, un gros bloc dont lequel on ne peut se d√©p√™trer, il aurait au contraire plut√¥t fait stagner PHP,
et n‚Äôaurait probablement pas eu autant de succ√®s. Symfony 4 / Flex a cass√© ce mythe et beaucoup de gens se sont remis √† Symfony pour l‚Äôoccasion.

Il peut donc √™tre pertinent de s‚Äôattarder un peu sur ces fameux composants de temps en temps, et de saisir leur int√©r√™t.
Car vous l‚Äôaurez compris, Symfony repose sur ceux-ci, et si vous utilisez le framework, vous utilisez forc√©ment les composants.


Mais comment ces composants sont-ils int√©gr√©s √† Symfony de mani√®re aussi transparente ?
Pour comprendre cela, il faut se pencher sur deux composants qui en sont le coeur m√™me : HttpKernel et EventDispatcher.


On va principalement s‚Äôattacher √† comprendre EventDispatcher aujourd‚Äôhui, parce qu‚Äôil y a beaucoup de choses √† dire sur cette librairie !

Pour cet article, je pars du principe que vous l‚Äôavez d√©j√† utilis√© au moins une fois.


## Qu‚Äôest-ce que l‚ÄôEventDispatcher ? (rapidement)


Il faut retenir que c‚Äôest un composant qui impl√©mente deux design patterns :
[Observer](https://refactoring.guru/design-patterns/observer) et [Mediator](https://refactoring.guru/design-patterns/mediator).


Observer : Un ou plusieurs "observeurs" sont enregistr√©s chez un ou plusieurs "sujets".
Lorsque qu‚Äôun sujet d√©cide que quelque chose de notable se produit, il notifie ses observers qui sont alors appel√©s √† leur tour.

Mediator : On ajoute un interm√©diaire entre les observeurs et les sujets, de sorte qu‚Äôil n‚Äôy ait pas de d√©pendance directe entre les deux.


**Concr√®tement** :

La classe EventDispatcher est l‚Äôimpl√©mentation de Mediator. Elle s‚Äôoccupe de m√©moriser les observeurs (autrement appel√©s Listeners).
Ceux-ci doivent √™tre li√©s √† un √©v√©nement (Event), qui sera √©mis par les sujets.
De cette mani√®re, les sujets n‚Äôont plus besoin de conna√Ætre leurs listeners, mais seulement l‚ÄôEventDispatcher, et c'est la responsabilit√© de ce dernier de les appeler.

Je ne vais pas trop m‚Äô√©taler sur cette partie car je ne suis pas un sp√©cialiste des design patterns et des diff√©rents termes, mais j‚Äôesp√®re avoir r√©sum√© √† peu pr√®s l‚Äôid√©e et que je n‚Äôai pas fait sursauter quelqu‚Äôun üòù

Je fais un petit apart√© sur les √©v√©nements.
Cette notion, en dehors de PHP, elle vous est peut-√™tre d√©j√† famili√®re : elle est au coeur de la programmation orient√©e √©v√®nements, qui est l‚Äôessence m√™me de Javascript.

Une des principales fonctionnalit√©s int√©gr√©es au coeur de Javascript est celle de pouvoir associer une fonction √† un √©l√©ment du DOM et √† un √©v√©nement,
de sorte que cette fonction soit appel√©e lorsque cet √©v√©nement se d√©clenche sur cet √©l√©ment : c‚Äôest `addEventListener()` !



C‚Äôest bien pratique dans un contexte de page web interactive, car on ne fait qu‚Äô√©mettre des √©v√©nements dans notre page :
cliquer sur une ic√¥ne, soumettre un formulaire, passer la souris sur un lien, sont autant d‚Äô√©v√©nements auxquels on peut avoir envie de r√©agir pour rendre la navigation plus fluide et/ou agr√©able.



Alors, ok pour une utilisation dans un tel contexte, mais en PHP, pourquoi donc ?

Par exemple, mettons que j‚Äôai une propri√©t√© `updated_at` sur une entit√© Doctrine que je veux mettre √† jour √† chaque update.
Il peut √™tre int√©ressant d‚Äôutiliser ce syst√®me, car on n‚Äôa pas forc√©ment envie de faire √ßa manuellement, surtout dans un cas comme celui-ci qui est cens√© √™tre une action syst√©matique.

Avec Doctrine ORM qui apporte son syst√®me d‚Äô√©v√©nements, je peux mettre √† jour cette propri√©t√© d√®s que mon entit√© est concern√©e par un flush en √©coutant l‚Äô√©v√©nement `onFlush`.
De cette mani√®re, cette logique l√† est s√©par√©e du reste du code, et je n‚Äôai pas √† m‚Äôen soucier √† chaque update !

Il y a [plusieurs mani√®res de faire](https://symfony.com/doc/current/doctrine/events.html), √† chacun de voir ce qu‚Äôil pr√©f√®re.
En tout cas, √ßa peut √™tre un cas d‚Äôutilisation valide.


On a vu que la programmation orient√©e objet √©tait pratique en Javascript, qu‚Äôelle est aussi applicable en PHP,
et que l‚ÄôEventDispatcher peut servir √† appliquer cette approche √† notre code PHP.



Mais on a surtout vu que l‚Äôint√©r√™t principal de l‚ÄôEventDispatcher, c‚Äôest le d√©couplage du code (je rappelle qu‚Äôil combine deux design patterns dont c‚Äôest la sp√©cialit√©) √† travers des √©v√©nements.

Apr√®s cette petit rappel de ce qu‚Äôest le composant, voyons comment il est utilis√© dans Symfony.


## Pourquoi un tel composant dans l‚Äô√©cosyst√®me ?

Dans Symfony, EventDispatcher est utilis√© dans plusieurs autres composants : HttpKernel, Form, Security, Workflow...

Dans ces composants sont d√©finis plusieurs `events`. Si on prend le cas d‚ÄôHttpKernel, on a les fameux Kernel Events (doc).
Ils sont dispatch√©s dans la classe [HttpKernel](https://github.com/symfony/http-kernel/blob/5.0/HttpKernel.php#L115).

```php
$this->requestStack->push($request);

// request

$event = new RequestEvent($this, $request, $type);

$this->dispatcher->dispatch($event, KernelEvents::REQUEST);
.....
$event = new ControllerEvent($this, $controller, $request, $type);
$this->dispatcher->dispatch($event, KernelEvents::CONTROLLER);

....

$event = new ControllerArgumentsEvent($this, $controller, $arguments, $request, $type);
$this->dispatcher->dispatch($event, KernelEvents::CONTROLLER_ARGUMENTS);

if (!$response instanceof Response) {
    $event = new ViewEvent($this, $request, $type, $response);
$this->dispatcher->dispatch($event, KernelEvents::VIEW);
....
}
```
Vous venez peut-√™tre bien de regarder le code de la classe la plus importante de Symfony !
HttpKernel ne fait pas grand chose, mais d√©j√† bien assez ; il d√©clare le cycle de vie d‚Äôune requ√™te et plusieurs points d‚Äôattache en √©mettant (dispatch) des √©v√©nements, que n‚Äôimporte qui peut √©couter pour s‚Äôy brancher.
C‚Äôest de cette mani√®re que les autres composants de Symfony sont li√©s au Kernel ! C‚Äôest gr√¢ce √† ce m√©canisme que nous pouvons avoir le framework que nous connaissons.
La requ√™te √† traiter est balad√©e √† travers diff√©rents √©v√©nements, tout comme le contr√¥leur et la r√©ponse ; les diff√©rents composants qui y sont li√©s les r√©cup√®rent et les traitent.

Prenons l‚Äôexemple du Routing de Symfony : vous-√™tes vous d√©j√† demand√© comment le routing √©tait appel√© ?
Si oui, sachez que c‚Äôest beaucoup moins cach√© qu‚Äôon ne pourrait le penser : tout se trouve dans [RouterListener](https://github.com/symfony/http-kernel/blob/5.0/EventListener/RouterListener.php#L97) !
On peut voir que cette classe impl√©mente EventSubscriberInterface et appelle le composant Routing sur l‚Äô√©v√©nement kernel.request.



Si vous passez un peu plus de temps dans [`Symfony\Component\HttpKernel\EventListener`](https://github.com/symfony/http-kernel/tree/5.0/EventListener), vous verrez que toutes les classes qui s‚Äôy trouvent sont d‚Äôautres listeners qui √©coutent des √©v√®nements du Kernel ! Ce sont ces listeners qui permettent d‚Äôappeler les autres composants de Symfony, s‚Äôils sont install√©s, pendant le parcours de la requ√™te.

Le [FrameworkBundle](https://github.com/symfony/framework-bundle), qui vient avec toute cr√©ation d‚Äôun projet Symfony, enregistre tous ces listeners dans le conteneur, et de cette mani√®re ils sont bien appel√©s au moment o√π les √©v√©nements du Kernel sont lanc√©s.


Je ne pourrai pas vous recommander assez assez la lecture de [cette page de doc]()(https://symfony.com/doc/current/components/http_kernel.html) ! Elle explique dans le d√©tail ce que je vous raconte.



HttpKernel, voil√† en quoi c‚Äôest un ‚Äúnoyau HTTP‚Äù : c‚Äôest d‚Äôici que tout part !
Pour r√©sumer : HttpKernel utilise EventDispatcher pour des events tout au long de la vie de l‚Äôapplication le temps d‚Äôune requ√™te.
Des listeners √©coutent ces √©vents et appellent les autres composants Symfony.
Voil√† pourquoi vous pouvez les utiliser dans votre application de mani√®re totalement transparente.
Et voil√† pourquoi HttpKernel et EventDispatcher peuvent vous servir √† [cr√©er votre propre framework](https://symfony.com/doc/current/create_framework/index.html) !
C‚Äôest une excellente m√©thode pour comprendre les choix qui ont √©t√© faits dans Symfony.

On constate donc que l‚Äôutilisation du composant EventDispatcher permet en fait de rendre Symfony totalement modulaire ! C‚Äôest un syst√®me de plugin.

Voil√† un cas d‚Äôutilisation tr√®s int√©ressant du composant, et qu n‚Äôa rien √† voir avec l‚Äôexemple de Doctrine listener que je donnais plus haut.
EventDispatcher est utilis√© √† un autre niveau, non pas pour r√©agir √† des √©v√©nements du mod√®le, mais au niveau de la structure de l‚Äôapplication en tant que telle.

## Est-ce pertinent d‚Äôutiliser EventDispatcher dans mon app ?


Comme on l‚Äôa vu plus haut, l‚Äôavantage de l‚Äôutilisation de l‚ÄôEventDispatcher, c‚Äôest de grandement d√©coupler sujet et listener.
C‚Äôest tr√®s utile dans certains cas, mais dans votre app, cela ne facilite pas du tout la lisibilit√©, la maintenabilit√© et le debug‚Ä¶
Je parlais tout √† l'heure de Javascript, ceux qui en font r√©guli√®rement le savent mieux que personne :
un petit script avec quelques listeners, √ßa reste g√©rable, mais quand l‚Äôapplication grandit on se retrouve rapidement avec un sac de noeuds.
C‚Äôest en partie pour cette raison que la tendance est aux librairies qui incitent √† d√©couper ses pages en composants : on r√©duit le scope dans lequel on d√©finit nos listeners.

Je ne connais pas d‚ÄôIDE √† l‚Äôheure actuelle capable de remonter les listeners √† partir d‚Äôun *event* donn√©.
Par exemple, si vous voulez conna√Ætre tous les listeners qui sont d√©clar√©s sur `kernel.request` √† partir du code, vous n‚Äôavez pas d‚Äôautre choix que de chercher cette chaine de caract√®re sur l‚Äôensemble du projet.
Heureusement, il existe [une commande](https://symfony.com/doc/current/event_dispatcher.html#debugging-event-listeners) qui r√©pond pr√©cis√©ment √† ce besoin.
Si vous utilisez *Symfony as a framework* vous avez aussi acc√®s au *profiler* qui vous liste les *listeners* appel√©s et non appel√©s sur une requ√™te donn√©e.
En tout cas, si jamais vous avez envie de vous lancer dans la cr√©ation d‚Äôun plugin PhpStorm, voil√† une id√©e !


Si vous avez besoin de suivre le changement d‚Äô√©tat de vos entit√©s (ex: pousser une notification quand un article passe du statut *draft* √† *published*),
vous pourriez √™tre tent√© d‚Äôutiliser un √©v√©nement pour cela et de vous brancher dessus.
Bien s√ªr, cela fonctionne, mais il peut √™tre int√©ressant d‚Äô√©tudier d‚Äôautres alternatives.
Il faut garder √† l‚Äôesprit qu‚Äô√† chaque fois que l‚Äôon ajoute un *listener*, on ajoute du code un peu planqu√©.

Sachez notamment qu‚Äôil existe nativement les classes [\SplSubject](https://www.php.net/manual/fr/class.splsubject.php) et [\SplObserver](https://www.php.net/manual/fr/class.splobserver.php) si l‚Äôenvie vous prend d‚Äôimpl√©menter le pattern Observer vous m√™me.

Quelques bonnes pratiques si toutefois vous voulez l‚Äôutiliser :
Evitez absolument de *dispatch* un *event* dans un *listener*. C‚Äôest possible, mais on amplifie encore plus ce probl√®me de ‚Äúcode cach√©‚Äù en ajoutant de la profondeur.

Les *Doctrine events* peuvent √™tre int√©ressants dans certains cas, mais il faut en user avec parcimonie.
Ce n‚Äôest en tout cas pas √† cet endroit que l‚Äôon va ajouter de la logique m√©tier. Le code qui est ex√©cut√© dans les listeners devrait √™tre court, simple et performant.

Il faut aussi garder √† l‚Äôesprit que si un listener est enregistr√© sur un *event*, il sera toujours ex√©cut√©, donc pr√©voir aussi une porte de sortie le plus t√¥t possible dans le cas o√π son ex√©cution n'est pas souhait√©e.
Typiquement dans les Doctrine Listeners, avant toute chose on commence toujours par regarder le type de l'entit√© pass√©e avant de continuer.

Si vous utilisez Symfony >4.3, sachez que vous n‚Äôavez plus besoin de d√©finir un *event* name si vous avez cr√©√© un custom *event*. [https://symfony.com/blog/new-in-symfony-4-3-simpler-event-dispatching](https://symfony.com/blog/new-in-symfony-4-3-simpler-event-dispatching).


J'esp√®re vous avoir donn√© envie de lire un le code de Symfony, vous avoir fait prendre conscience qu'il est tout √† fait accessible, et peut-√™tre qu'un jour l'envie vous prendra de contribuer !
N'h√©sitez pas √† me dire dans les commentaires si quelque chose n'est pas clair.

A bient√¥t peut-√™tre en meetup Sfpot !

{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('build/images/avent/remi_andrieux.jpg') }}" alt="R√©mi Andrieux"/>
{% endblock %}

{% block article_bio %}
    <h2>
        <a href="{% block author_url 'https://twitter.com/pimolo_' %}" target="_blank">
            {% block article_author 'R√©mi Andrieux' %}
        </a>
    </h2>
    <p>
        <span lang="fr">D√©veloppeur PHP</span> chez
        <a href="https://dental-monitoring.com/?lang=fr" target="_blank">Dental Monitoring</a>.
    </p>
{% endblock %}
