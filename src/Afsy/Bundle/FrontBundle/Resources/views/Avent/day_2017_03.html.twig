{% extends 'AfsyFrontBundle:Avent:day.html.twig' %}

{% set year = 2017 %}

{% block article_title "Jour 3 - D√©ployer un projet Symfony 4 avec Flex sur Heroku" %}

{% block article_content %}
    <h1 id="d√©ployer-un-projet-symfony-flex-sur-heroku">D√©ployer un projet Symfony 4 avec Flex sur Heroku</h1>

    <p>Nous allons aborder trois sujets ici¬†:</p>

    <ul>
        <li>Qu'est-ce que Flex ?</li>
        <li>Heroku, c'est quoi ?</li>
        <li>Cr√©ons notre projet et d√©ployons-le !</li>
    </ul>

    <h2 id="quest-ce-que-flex">Qu'est-ce que Flex ?</h2>

    <p>Flex, parfois appel√© Symfony Flex, est un plugin Composer que vous pouvez installer dans tout projet PHP, et qui va permettre de standardiser la structure et la composition d'un projet.</p>

    <p>D'autres articles existent √† ce propos, notamment dans le cadre de ce calendrier de l'avent, et je ne vais donc pas trop m'√©taler sur le sujet.</p>

    <p>En quelques phrases, je peux vous dire que Flex¬†:</p>

    <ul>
        <li>Permet d'utiliser certains alias pour installer un ou plusieurs packages (comme <code>cli</code> pour <code>symfony/console</code>, ou <code>orm</code> pour plusieurs packages relatifs √† l'ORM Doctrine).</li>
        <li>Permet d'automatiser la configuration par d√©faut d'un package via des "recettes" (<code>recipe</code>) pouvant √™tre d√©finies dans les repositories publics <a href="https://github.com/symfony/recipes-contrib">symfony/recipes-contrib</a> et <a href="https://github.com/symfony/recipes">symfony/recipes</a></li>
        <li>Gr√¢ce √† la nouvelle structure de Symfony 4 &amp; Flex, standardise totalement la structure d'un projet PHP ainsi que l'utilisation de variables d'environnement et de scripts composer automatis√©s.</li>
    </ul>

    <h2 id="heroku-cest-quoi">Heroku, c'est quoi ?</h2>

    <p>C'est une plateforme permettant de faire du cloud-computing.</p>

    <p>On peut l'utiliser pour h√©berger des bases de donn√©es, des applications (web, workers, etc.), et les orchestrer.</p>

    <p>Sa configuration peut √™tre faite via l'utilisation d'une ligne de commande, ou par un tableau de bord en ligne, les deux √©tant facilement accessibles.</p>

    <h3 id="prix">Prix</h3>

    <p>Heroku est payant mais propose un acc√®s gratuit jusqu'√† un certain nombre d'heures d'utilisation. Dans le cas d'une application web, celle-ci rentre dans un √©tat de "sommeil" apr√®s 30 minutes d'activit√©, permettant d'√©conomiser le temps disponible. La formule gratuite est par cons√©quent tr√®s pratique pour les prototypes ou les environnements d'int√©gration continue.</p>

    <p>Pour le reste, le prix d√©pend des performances que vous souhaitez, des add-ons que vous utilisez, et surtout du temps d'utilisation.</p>

    <p>Par exemple, un abonnement <code>Hobby</code> √† $7 par mois vous co√ªtera seulement $3.50 si vous l'utilisez 15 jours et le d√©sactivez ensuite. C'est tr√®s important √† savoir, car la facture sera calcul√©e en fonction du temps d'ex√©cution de vos Dynos (voir plus loin).</p>

    <h3 id="un-serveur-heroku">Un serveur Heroku</h3>

    <p>Les machines utilisent une distribution nomm√©e Cedar, qui est bas√©e sur Ubuntu, et on peut configurer une application pour utiliser Cedar 14.04 ou Cedar 16.04 (les derni√®res LTS de Ubuntu).</p>

    <p>Les applications sont ex√©cut√©es dans des containers Linux appel√©s <strong>Dynos</strong>.</p>

    <p>Il existe trois types de Dynos¬†: <code>web</code>, <code>worker</code> et <code>one-off</code> et ils sont configur√©s par un fichier nomm√© <code>Procfile</code>.</p>

    <ul>
        <li>Les dynos <code>web</code> sont ex√©cut√©s de fa√ßon persistante et sont configur√©s par votre <code>Procfile</code> et sont les seuls √† recevoir les requ√™tes HTTP envoy√©es sur votre application.</li>
        <li>Les dynos <code>worker</code> sont des scripts configur√©s dans votre <code>Procfile</code> et sont majoritairement utilis√©s pour des t√¢ches de fond, comme des Queues.</li>
        <li>Les dynos <code>one-off</code> sont des dynos temporaires que vous pouvez cr√©er, par exemple en ex√©cutant manuellement des scripts en ligne de commande avec <code>heroku run {script...}</code>. Ils sont utilis√©s √©galement au d√©ploiement d'une release (cela permet d'√©viter qu'un d√©ploiement de 10 minutes soit d√©compt√© de votre temps de gratuit√©‚Ä¶), mais aussi par le <code>Heroku Scheduler</code> pour orchestrer des t√¢ches de fond (similaire √† <code>crontab</code>).</li>
    </ul>

    <p>Que votre application soit de type <code>web</code>, <code>worker</code> ou autre, l'ex√©cution sera toujours effectu√©e dans un Dyno.</p>

    <h3 id="personnaliser-notre-serveur">Personnaliser notre serveur</h3>

    <p>En tant qu'utilisateur, <strong>nous n'avons pas acc√®s √† la distribution</strong>. Nous ne pouvons donc pas modifier les packages de la machine.</p>

    <p>En revanche, pour pallier cela, Heroku utilise un syst√®me de <strong>buildpacks</strong> et d'<strong>add-ons</strong> qui, eux, vont pouvoir ex√©cuter des commandes dans la machine afin d'installer certains packages.</p>

    <h4 id="les-buildpacks">Les buildpacks</h4>

    <p>Les buildpacks comprennent un ensemble de scripts ayant plusieurs responsabilit√©s¬†:</p>

    <ul>
        <li>D√©tecter le "type" de votre application (Ruby, PHP, Javascript, etc.).</li>
        <li>Compiler votre application en ex√©cutant des scripts (installer des d√©pendances, etc.).</li>
        <li>Mettre √† jour votre configuration Heroku apr√®s l'installation, comme installer des add-ons ou changer le script par d√©faut ex√©cuter sur un dyno.</li>
    </ul>

    <p>Par exemple, le buildpack <strong>PHP</strong> est d√©tect√© automatiquement si un fichier <code>composer.json</code> est pr√©sent √† la racine de votre projet.</p>

    <p>Il est √©galement capable d'installer des extensions PHP si celles-ci sont pr√©sentes dans la section <code>require</code> de votre <code>composer.json</code>, comme <code>"require": { "ext-intl": "*" }</code> par exemple.</p>

    <p>Les buildpacks sont indispensables √† la configuration de base d'une application. √Ä moins que vous n'ex√©cutiez que des scripts en bash‚Ä¶</p>

    <h4 id="les-add-ons">Les add-ons</h4>

    <p>Les add-ons, eux, sont g√©n√©ralement l√† pour int√©grer des services externes √† votre projet, comme des bases de donn√©es, des rapports de logs, du profiling ou un syst√®me d'envoi de mails.</p>

    <p>La plupart des add-ons sont payants mais offrent une option gratuite avec des services et performances limit√©s.</p>

    <p>Ils ont plusieurs avantages¬†:</p>

    <ul>
        <li>Ils sont souvent capables d'ajouter automatiquement des variables d'environnement √† votre configuration afin que vous puissiez l'utiliser dans votre projet. </li>
        <li>Ils permettent de d√©tacher l'application de ses services (par exemple, en mettant la BDD sur un serveur externe), ce qui facilite grandement la maintenance et nous permet de nous  passer compl√®tement d'infog√©rance sur tous ces services. </li>
        <li>Et comme avec d'autres services de <em>cloud computing</em> (comme <a href="https://sensio.cloud">SensioCloud</a>), cela se conjugue tr√®s bien avec les derni√®res bonnes pratiques de Symfony qui recommandent l'utilisation de variables d'environnement.</li>
    </ul>

    <p>De fa√ßon g√©n√©rale vous aurez quasiment toujours besoin d'addons, ne serait-ce pour la base de donn√©es et l'envoi de mails, et les offres gratuites sont largement suffisantes pour des projets simples et peu gourmands en ressources.</p>

    <h2 id="cr√©ation-dun-projet-symfony-4-avec-flex">Cr√©ation d'un projet Symfony 4 avec Flex</h2>

    <p>Allez, maintenant qu'on sait en quoi consistent les outils que nous allons utiliser, servons-nous-en !</p>

    <p>Tout d'abord, on cr√©e le projet quelque part sur notre machine¬†:</p>

    <pre><code class="language-sh">$ composer create-project symfony/skeleton:^4.0 my_project</code></pre>

    <p>Le package <code>symfony/skeleton</code> ne contient qu'une seule chose¬†: un fichier <code>composer.json</code> d√©terminant quelques d√©pendances pour cr√©er un projet web avec Symfony, dont Flex.</p>

    <p>Les d√©pendances principales qui nous permettent de faciliter tout √ßa sont les suivantes¬†:</p>

    <ul>
        <li><code>symfony/flex</code>¬†: Le plugin Composer dont on parlait au d√©but de cet article.</li>
        <li><code>symfony/lts</code>¬†: Un simple package composer permettant de d√©finir quelle version majeure de Symfony nous allons utiliser. Ce package d√©finit simplement des conflits de version avec la version majeure sup√©rieure.</li>
        <li><code>symfony/framework-bundle</code>¬†: Le package principal qui nous permet de cr√©er un projet web avec Symfony.</li>
    </ul>

    <p>L'avantage, c'est que ce dernier package dispose d'une <a href="https://github.com/symfony/recipes/tree/master/symfony/framework-bundle/3.3">recette Flex</a> qui va initialiser tout un tas d'outils dans notre projet¬†:</p>

    <ul>
        <li>La configuration par d√©faut du framework dans le dossier <code>config/</code>.</li>
        <li>Un front-controller dans un dossier <code>public/</code>.</li>
        <li>Un micro-kernel pr√©configur√© dans <code>src/Kernel.php</code>.</li>
        <li>Des variables d'environnement et des fichiers <code>.env</code> et <code>.env.dist</code> pour configurer notre projet.</li>
        <li>Un fichier <code>.gitignore</code> d√©j√† pr√™t √† l'usage.</li>
        <li>Des scripts Composer pour vider le cache et installer les assets √† chaque <code>composer install/update</code></li>
    </ul>

    <p>Et √©tant donn√© que <code>symfony/console</code> est d√©sormais une d√©pendance de base de <code>symfony/skeleton</code>, Flex va √©galement suivre la <a href="https://github.com/symfony/recipes/tree/master/symfony/console/3.3">recette</a> de ce package et installer un fichier <code>bin/console</code> comme nous l'adorons dans Symfony !</p>

    <p>Toutes ces actions sont d√©finies dans les diff√©rentes <strong>recettes</strong> des packages en question, et l'avantage c'est que gr√¢ce √† Flex, si nous supprimons un package, tout ce qui a √©t√© pr√©alablement install√© et configur√© par cette recette sera supprim√© ! Plus besoin de se prendre la t√™te avec des suppressions manuelles si on d√©sire supprimer un package !</p>

    <h3 id="cr√©er-un-environnement-git">Cr√©er un environnement <code>git</code></h3>

    <p>C'est aujourd'hui indispensable √† tout projet !</p>

    <pre><code class="language-sh">$ git init</code></pre>

    <p>Nous utiliserons Git plus tard, mais il fallait au moins pr√©parer le terrain.</p>

    <h3 id="installons-le-serveur-web-de-symfony">Installons le serveur web de Symfony</h3>

    <p>Pour tester notre projet nous allons utiliser le bundle <code>WebServerBundle</code> de Symfony, qui nous permet d'ex√©cuter des commandes utilisant le serveur PHP int√©gr√© afin de pouvoir lancer notre projet en dev¬†:</p>

    <pre><code class="language-sh">$ composer require --dev server</code></pre>

    <p><code>server</code> est simplement un alias du package <code>symfony/web-server-bundle</code>, encore une fois, merci Flex !</p>

    <h3 id="cr√©ons-un-contr√¥leur-par-d√©faut">Cr√©ons un contr√¥leur par d√©faut</h3>

    <p>Ce contr√¥leur sera n√©cessaire, car d√©sormais il n'y a plus de contr√¥leur par d√©faut dans Symfony¬†:</p>

    <pre><code class="language-php">&lt;?php

// src/Controller/DefaultController.php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class DefaultController
{
    /**
     * @Route("/", name="homepage")
     */
    public function index(): Response
    {
        return new Response('It works! ‚ò∫');
    }
}</code></pre>

    <p>Et n'oublions pas d'installer les annotations, pour que √ßa fonctionne¬†:</p>

    <pre><code class="language-sh">$ composer req annot
Using version ^5.1 for sensio/framework-extra-bundle
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 7 installs, 0 updates, 0 removals
  - Installing doctrine/lexer (v1.0.1): Loading from cache
  - Installing doctrine/inflector (v1.2.0): Loading from cache
  - Installing doctrine/collections (v1.5.0): Loading from cache
  - Installing doctrine/cache (v1.7.1): Loading from cache
  - Installing doctrine/annotations (v1.5.0): Loading from cache
  - Installing doctrine/common (v2.8.1): Loading from cache
  - Installing sensio/framework-extra-bundle (v5.1.2): Loading from cache
Writing lock file
Generating autoload files
Symfony operations: 2 recipes (3ac0e3828e0167b379d5284080768bc5)
  - Configuring doctrine/annotations (>=1.0): From github.com/symfony/recipes:master
  - Configuring sensio/framework-extra-bundle (>=4.0): From github.com/symfony/recipes:master
Executing script cache:clear [OK]
Executing script assets:install --symlink --relative public [OK]
</code></pre>

    <p>La recette de <code>doctrine/annotations</code> contient un fichier tr√®s utile¬†:</p>

    <pre><code class="language-yaml"># config/routes/annotations.yaml
controllers:
    resource: ../../src/Controller/
    type: annotation</code></pre>

    <p>Et hop ! Tous nos contr√¥leurs seront d√©sormais automatiquement charg√©s via des annotations !</p>

    <h3 id="testons-cette-configuration">Testons cette configuration</h3>

    <p>On ex√©cute la commande du <code>WebServerBundle</code> pour voir notre site¬†:</p>

    <pre><code class="language-sh">$ php bin/console server:run

 [OK] Server listening on http://127.0.0.1:8000

 // Quit the server with CONTROL-C.
</code></pre>

    <p>Cela nous donne une page de ce genre¬†:</p>

    <p><img src="{{ asset('bundles/afsyfront/images/avent/2017/03/default_localhost_works.jpg') }}" alt="localhost default working project" title=""></p>

    <p>Super ! √áa fonctionne, donc on peut partir du principe qu'on a un projet Symfony op√©rationnel !</p>

    <h3 id="installation-de-la-ligne-de-commande-heroku">Installation de la ligne de commande Heroku</h3>

    <p>Maintenant nous allons pr√©parer le d√©ploiement sur Heroku.</p>

    <p>Dans un premier temps il faut t√©l√©charger l'application en ligne de commande fournie par Heroku¬†: <a href="https://devcenter.heroku.com/articles/heroku-cli#download-and-install">https://devcenter.heroku.com/articles/heroku-cli#download-and-install</a></p>

    <p>Une fois fait, on peut l'ex√©cuter pour v√©rifier qu'elle est bien install√©e et fonctionnelle¬†:</p>

    <pre><code class="language-sh">$ heroku --version
heroku-cli/6.14.36-15f8a25 (linux-x64) node-v8.7.0</code></pre>

    <h3 id="se-connecter-avec-heroku">Se connecter avec Heroku</h3>

    <p>√âvidemment, il faut d'abord <a href="https://signup.heroku.com/">cr√©er un compte sur Heroku</a>, et une fois fait, il faut indiquer √† la CLI de Heroku quel compte nous utilisons¬†:</p>

    <pre><code class="language-sh">$ heroku login
Enter your Heroku credentials:
Email: me@domain.com
Password: *************‚ñà
Logged in as me@domain.com</code></pre>

    <p>Cela va permettre √† Heroku CLI de nous donner des d√©tails sur nos projets, leur configuration, etc.</p>

    <p>√Ä partir de maintenant, <strong>toutes les commandes <code>heroku</code> seront ex√©cut√©es depuis le dossier du projet</strong>.</p>

    <h3 id="cr√©er-le-projet-sur-heroku">Cr√©er le projet sur Heroku</h3>

    <p>Heroku permet de tout faire depuis la ligne de commande, alors profitons-en¬†:</p>

    <pre><code class="language-sh">$ heroku create
Creating app... done, stark-escarpment-87840
https://stark-escarpment-87840.herokuapp.com/ | https://git.heroku.com/stark-escarpment-87840.git</code></pre>

    <p>Celui-ci nous donne l'URL finale du projet (utilisant le nom de domaine <code>herokuapp.com</code>) ainsi que l'URL de la remote <code>git</code> √† utiliser.</p>

    <h3 id="installer-le-buildpack">Installer le buildpack</h3>

    <p>Nous allons installer le buildpack PHP pour √™tre s√ªrs de pouvoir automatiser tout ce dont nous avons besoin¬†:</p>

    <pre><code class="language-sh">$ heroku buildpacks:set heroku/php
$ heroku buildpacks:set heroku/php
Buildpack set. Next release on stark-escarpment-87840 will use heroku/php.
Run git push heroku master to create a new release using this buildpack.</code></pre>

    <p><strong>Note¬†:</strong> En r√©alit√© nous n'avons pas vraiment besoin d'installer ce buildpack, puisqu'il est d√©tect√© automatiquement gr√¢ce √† la pr√©sence d'un fichier <code>composer.json</code> √† la racine de notre projet. Mais nous l'ajoutons manuellement histoire de faire les choses proprement.</p>

    <p>Heroku nous propose de d√©ployer mais nous ferons √ßa plus tard, quand le projet sera pr√™t¬†:)</p>

    <h3 id="rajouter-la-branche-heroku-en-tant-que-remote">Rajouter la branche Heroku en tant que <code>remote</code></h3>

    <p>L'int√©r√™t de cette remote est de pouvoir d√©ployer avec un simple <code>git push</code>.</p>

    <p>Et l'url vient de nous √™tre donn√©e, alors un simple copier/coller suffit¬†:</p>

    <pre><code class="language-sh">$ git remote add heroku https://git.heroku.com/stark-escarpment-87840.git</code></pre>

    <p><strong>Note¬†:</strong> nommer la remote <code>heroku</code> permet √† Heroku CLI de d√©tecter automatiquement le projet en cours sans avoir √† le sp√©cifier en tant qu'argument √† chaque commande.</p>

    <h3 id="acc√©der-√†-la-production">Acc√©der √† la production</h3>

    <p>Pour acc√©der directement √† l'url de notre projet, on peut ex√©cuter cette commande¬†:</p>

    <pre><code class="language-sh">$ heroku open</code></pre>

    <p>Vous devriez voir quelque chose de ce genre¬†:</p>

    <p><img src="{{ asset('bundles/afsyfront/images/avent/2017/03/heroku_default_home.jpg') }}" alt="heroku default home" title=""></p>

    <p>√âvidemment, pour l'instant il n'y a rien, mais au moins nous savons que Heroku a entendu nos demandes.</p>

    <h3 id="ajout-des-variables-denvironnement">Ajout des variables d'environnement</h3>

    <p>En premier lieu, il faut rajouter les variables d'environnement que Symfony nous dit de sp√©cifier.</p>

    <p>Les r√©f√©rences sont dans <code>.env.dist</code>, et √† chaque package que nous ajouterons, si des variables sont ajout√©es, il faudra les rajouter manuellement √† Heroku.</p>

    <p>Pour l'instant, seules 2 variables sont demand√©es par Symfony¬†:</p>

    <pre><code class="language-sh">$ heroku config:set APP_ENV=prod APP_SECRET=Wh4t3v3r</code></pre>

    <h3 id="pr√©parons-notre-projet-pour-quil-soit-compatible-avec-heroku">Pr√©parons notre projet pour qu'il soit compatible avec Heroku</h3>

    <p>En premier lieu il faut cr√©er un <code>Procfile</code>.</p>

    <p>Le <code>Procfile</code> est un fichier qui d√©crit les diff√©rents dynos que vous allez poss√©der dans votre projet.</p>

    <p>Chaque dyno sera comptabilis√© dans le temps de consommation relatif √† votre abonnement.</p>

    <p>Ici nous n'avons besoin que d'un seul dyno, en l'occurence un dyno de type <code>web</code>.</p>

    <p>Chaque ligne du fichier se compose de deux informations¬†: le type de dyno et le script √† ex√©cuter.</p>

    <p>Le script correspondra ici √† celui document√© dans le buildpack PHP, en l'occurrence une instance nginx suivie du nom du dossier servant de point d'entr√©e au vhost.</p>

    <pre><code>web: vendor/bin/heroku-php-nginx public/</code></pre>

    <p>Cela suffira √† Heroku pour qu'il puisse ex√©cuter notre code.</p>

    <p>Il est possible de personnaliser le vhost nginx ainsi que la configuration de php-fpm, mais c'est juste l'affaire d'un argument sp√©cifiant le fichier utilis√©, et nous n'en avons pas besoin pour l'instant.</p>

    <h3 id="d√©ployer-le-projet-sur-heroku">D√©ployer le projet sur Heroku</h3>

    <p>Du coup, d√©ployons notre projet !</p>

    <pre><code class="language-sh">$ git add .
$ git commit -m "Initial files"
$ git push heroku master
(...)
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----&gt; PHP app detected
remote: -----&gt; Bootstrapping...
remote: -----&gt; Installing platform packages...
remote:        - php (7.1.11)
remote:        - nginx (1.8.1)
remote:        - apache (2.4.29)
remote: -----&gt; Installing dependencies...
remote:        Composer version 1.5.2 2017-09-11 16:59:25
remote:        Loading composer repositories with package information
remote:        Installing dependencies from lock file
remote:        Package operations: 40 installs, 0 updates, 0 removals
remote:        (...)
remote:        Generating optimized autoload files
remote:        (...)
remote:        Executing script cache:clear [OK]
remote:        Executing script assets:install --symlink --relative public [OK]
remote:
remote: -----&gt; Preparing runtime environment...
remote: -----&gt; Checking for additional extensions to install...
remote: -----&gt; Discovering process types
remote:        Procfile declares types -&gt; web
remote:
remote: -----&gt; Compressing...
remote:        Done: 16.7M
remote: -----&gt; Launching...
remote:        Released v13
remote:        https://stark-escarpment-87840.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/stark-escarpment-87840.git</code></pre>

    <p>Le projet est maintenant d√©ploy√©, nous pouvons l'ouvrir et le tester¬†:</p>

    <pre><code class="language-sh">$ heroku open</code></pre>

    <p>Et nous devrions voir ceci¬†:</p>

    <p><img src="{{ asset('bundles/afsyfront/images/avent/2017/03/heroku_prod_works.jpg') }}" alt="heroku prod working" title=""></p>

    <hr>

    <p>Bon, maintenant que le projet est d√©ploy√©, nous n'allons pas nous arr√™ter l√†, n'est-ce pas ?</p>

    <p>Nos projets sont bien plus complexes et utilisent d'autres composants, alors continuons sur notre lanc√©e.</p>

    <h3 id="installer-une-base-de-donn√©es">Installer une base de donn√©es</h3>

    <h4 id="pr√©parer-le-projet-lui-m√™me">Pr√©parer le projet lui-m√™me</h4>

    <p>D'abord, installer Doctrine ORM¬†:</p>

    <pre><code class="language-sh">$ composer require orm-pack
Using version ^1.0 for symfony/orm-pack
(...)
Symfony operations: 3 recipes (7d946f30d2601a4530d4c10790aefad1)
  - Configuring doctrine/doctrine-cache-bundle (1.3.2): From auto-generated recipe
  - Configuring doctrine/doctrine-bundle (1.6): From github.com/symfony/recipes:master
  - Configuring doctrine/doctrine-migrations-bundle (1.2): From github.com/symfony/recipes:master
(...)</code></pre>

    <p>Les diff√©rentes recettes Flex vont rajouter ceci¬†:</p>

    <ul>
        <li><code>DoctrineBundle</code>¬†: <br>
            <ul><li>La variable d'environnement <code>DATABASE_URL</code> √† notre fichier <code>.env</code>.</li>
                <li>La configuration par d√©faut du bundle, utilisant cette m√™me variable d'environnement.</li></ul></li>
        <li><code>DoctrineMigrationsBundle</code>¬†: <br>
            <ul><li>La configuration du bundle, permettant de stocker nos migrations dans <code>src/Migrations</code>.</li></ul></li>
    </ul>

    <p>Nous reviendrons plus tard sur les migrations.</p>

    <h4 id="pr√©parer-la-bdd-sur-heroku">Pr√©parer la BDD sur Heroku</h4>

    <p>Ensuite, il faut installer l'addon Heroku n√©cessaire √† l'utilisation de notre base de donn√©es¬†:</p>

    <pre><code class="language-sh">$ heroku addons:create heroku-postgresql:hobby-dev
Creating heroku-postgresql:hobby-dev on stark-escarpment-87840... free
Database has been created and is available
 ! This database is empty. If upgrading, you can transfer
 ! data from another database with pg:copy
Created postgresql-flexible-83322 as DATABASE_URL
Use heroku addons:docs heroku-postgresql to view documentation</code></pre>

    <p>Du coup, Heroku va utiliser un autre serveur (qui ne nous concerne pas) pour g√©rer la base de donn√©es, ce qui facilite grandement la gestion &amp; migration de l'application tout en laissant la BDD de son c√¥t√©.</p>

    <p><strong>Note¬†:</strong> Par d√©faut j'utilise PostgreSQL ici, tout simplement parce qu'Heroku dispose de facilit√©s d'utilisations et de monitoring avec ce SGBD, mais il existe aussi de tr√®s bons add-ons pour MySQL ou MariaDB, comme ClearDB ou JawsDB, qui sont eux aussi des services cloud externes, et qui peuvent √™tre int√©gr√©s √† Heroku tout comme <code>heroku-postgresql</code>.<br>
        Il faut donc <strong>obligatoirement</strong> modifier nos fichiers <code>.env</code> et <code>.env.dist</code> pour changer le driver PDO de <code>mysql</code> (utilis√© par d√©faut) √† <code>pgsql</code>.</p>

    <p>L'installation de l'addon aura automatiquement rajout√© une variable d'environnement √† la configuration du projet¬†:</p>

    <pre><code class="language-bash">$ heroku config
=== stark-escarpment-87840 Config Vars
APP_ENV:      prod
APP_SECRET:   Wh4t3v3r
DATABASE_URL: postgres://...  &lt;--- Cette variable vient d'√™tre rajout√©e par l'addon heroku-postgresql</code></pre>

    <p><strong>Note¬†:</strong> Les autres add-ons cit√©s plus haut pour MySQL et MariaDB peuvent avoir une variable d'environnement avec un nom diff√©rent. Libre √† vous de changer vos fichiers <code>.env</code>, votre configuration Doctrine ou votre configuration Heroku, afin de l'utiliser.</p>

    <p>Il ne reste plus qu'√† cr√©er nos entit√©s comme on le fait habituellement !</p>

    <p>Par contre, pour le sch√©ma, il est pr√©f√©rable de tout faire via des migrations.</p>

    <p>Et en parlant de migrations‚Ä¶ Comment les ex√©cuter sur Heroku ?</p>

    <h3 id="personnaliser-les-scripts-de-d√©ploiement">Personnaliser les scripts de d√©ploiement</h3>

    <p>Avant de parler de nos migrations, voyons comment personnaliser nos d√©ploiements.</p>

    <p>Heroku se base sur les buildpacks pour d√©terminer les commandes √† ex√©cuter lors d'une release.</p>

    <p>Vu que notre projet est majoritairement un projet PHP, le buildpack PHP permet de cr√©er un script dans la section <code>scripts</code> de notre fichier <code>composer.json</code>¬†: <code>compile</code>.</p>

    <p>Ce script est ex√©cut√© au moment du d√©ploiement, via <code>composer compile</code> (et Composer d√©tecte automatiquement que cette commande n'existe pas nativement alors il tente de la r√©cup√©rer dans <code>composer.json</code>).</p>

    <p>L'avantage c'est que si ce script √©choue, le d√©ploiement n'a pas lieu !</p>

    <p>On peut donc y mettre nos migrations.</p>

    <h4 id="cr√©er-notre-migration">Cr√©er notre migration</h4>

    <p>Cr√©ons notre base de donn√©es ainsi que la premi√®re migration n√©cessaire.</p>

    <pre><code class="language-sh">$ php bin/console doctrine:database:create
$ php bin/console doctrine:migrations:diff</code></pre>

    <p><strong>Note¬†:</strong> Cette commande fonctionne <strong>uniquement</strong> si vous avez une <strong>base de donn√©es enti√®rement vide</strong>.<br>
        Dans le doute, si vous voulez √™tre s√ªr que la migration cr√©√©e est correcte, vous pouvez ex√©cuter cette suite de <br>
        commandes:</p>

    <pre><code class="language-sh">$ php bin/console doctrine:database:drop --force
$ php bin/console doctrine:database:create
$ php bin/console doctrine:migrations:diff</code></pre>

    <p>Et sinon, cr√©ez une migration avec la commande <code>doctrine:migrations:generate</code>, copiez un <em>dump</em> de votre base de donn√©es et collez-le directement dans le fichier de migration fra√Æchement cr√©√©.</p>

    <p>Une fois fait, vous devriez avoir quelque chose de ce style¬†:</p>

    <pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * Auto-generated Migration: Please modify to your needs!
 */
class Version20171106100053 extends AbstractMigration
{
    public function up(Schema $schema)
    {
        // this up() migration is auto-generated, please modify it to your needs
        $this-&gt;abortIf($this-&gt;connection-&gt;getDatabasePlatform()-&gt;getName() !== 'postgresql', 'Migration can only be executed safely on \'postgresql\'.');

        $this-&gt;addSql('CREATE SEQUENCE Post_id_seq INCREMENT BY 1 MINVALUE 1 START 1');
        $this-&gt;addSql('CREATE TABLE Post (id INT NOT NULL, title VARCHAR(255) NOT NULL, content TEXT NOT NULL, PRIMARY KEY(id))');
    }

    public function down(Schema $schema)
    {
        // this down() migration is auto-generated, please modify it to your needs
        $this-&gt;abortIf($this-&gt;connection-&gt;getDatabasePlatform()-&gt;getName() !== 'postgresql', 'Migration can only be executed safely on \'postgresql\'.');

        $this-&gt;addSql('CREATE SCHEMA public');
        $this-&gt;addSql('DROP SEQUENCE Post_id_seq CASCADE');
        $this-&gt;addSql('DROP TABLE Post');
    }
}</code></pre>

    <p>Si vous avez bien votre migration, continuons !</p>

    <h4 id="ajouter-les-migrations-√†-notre-d√©ploiement">Ajouter les migrations √† notre d√©ploiement</h4>

    <p>Pour ex√©cuter nos migrations, il suffit d'une seule commande¬†:</p>

    <pre><code class="language-sh">$ php bin/console doctrine:migrations:migrate

                    Application Migrations

WARNING! You are about to execute a database migration that could result in schema changes and data lost. Are you sure you wish to continue? (y/n)y
Migrating up to 20171106100053 from 0

  ++ migrating 20171106100053

     -&gt; CREATE SEQUENCE Post_id_seq INCREMENT BY 1 MINVALUE 1 START 1
     -&gt; CREATE TABLE Post (id INT NOT NULL, title VARCHAR(255) NOT NULL, content TEXT NOT NULL, PRIMARY KEY(id))

  ++ migrated (2.7s)

  ------------------------

  ++ finished in 2.7s
  ++ 1 migrations executed
  ++ 2 sql queries
</code></pre>

    <p>En l'ex√©cutant en local, tout fonctionne. Maintenant, il faut l'ex√©cuter en production, et <strong>seulement au d√©ploiement</strong>.</p>

    <p>Rajoutons donc un script Composer pour √ßa, mais pas n'importe lequel¬†: le script que le buildpack PHP d√©clenche au moment du d√©ploiement (voir plus haut).</p>

    <pre><code class="language-json">{
    "scripts": {
        "compile": [
            "php bin/console doctrine:migrations:migrate"
        ]
    }
}</code></pre>

    <p>C'est tout !</p>

    <p>√Ä chaque d√©ploiement cette commande sera ex√©cut√©e dans le contexte de l'application. Et vu que tout le contexte h√©rite des variables d'environnement, m√™me pas besoin de sp√©cifier <code>--env=prod</code> comme on le faisait avant !</p>

    <p>Et maintenant on d√©ploie √† nouveau¬†:</p>

    <pre><code class="language-sh">$ git add . &amp;&amp; git commit -m "Setup migrations"
$ git push heroku master
(...)
remote: -----&gt; Running 'composer compile'...
remote:        &gt; php bin/console doctrine:migrations:migrate
remote:
remote:                            Application Migrations
remote:
remote:
remote:        Migrating up to 20171106100053 from 0
remote:
remote:          ++ migrating 20171106100053
remote:
remote:             -&gt; CREATE SEQUENCE Post_id_seq INCREMENT BY 1 MINVALUE 1 START 1
remote:             -&gt; CREATE TABLE Post (id INT NOT NULL, title VARCHAR(255) NOT NULL, content TEXT NOT NULL, PRIMARY KEY(id))
remote:
remote:          ++ migrated (0.06s)
remote:
remote:          ------------------------
remote:
remote:          ++ finished in 0.06s
remote:          ++ 1 migrations executed
remote:          ++ 2 sql queries
(...)</code></pre>

    <p>Les migrations ont √©t√© ex√©cut√©es sur la base de production g√©r√©e par Heroku, tout est ok !</p>

    <h3 id="ex√©cuter-des-cron-avec-heroku-et-symfony">Ex√©cuter des <code>cron</code> avec Heroku et Symfony</h3>

    <p>Tout d'abord, il nous faut une commande √† ex√©cuter, cr√©ons-en donc une simple:</p>

    <pre><code class="language-php">&lt;?php

namespace App\Command;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class SimpleMessageCommand extends Command
{
    protected static $defaultName = 'app:simple-message';

    protected function configure()
    {
        $this-&gt;setDescription('Simply sends a message to stdout and stderr.');
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $now = date('Y-m-d H:i:s');
        $output-&gt;writeln("[$now] Stdout message");
        fwrite(STDERR, "[$now] Stderr message");
    }
}</code></pre>

    <p>L'id√©e c'est de pouvoir consulter les logs de Heroku pour voir ces messages.</p>

    <p><strong>Pro tip:</strong> Depuis Symfony 3.4, on peut utiliser la propri√©t√© statique <code>Command::$defaultName</code>. Si notre commande est d√©finie en tant que service, cela permettra √† Symfony d'optimiser le chargement de la console et la compilation du container en n'instanciant pas la commande.</p>

    <h4 id="installer-heroku-scheduler">Installer Heroku Scheduler</h4>

    <p>Heroku Scheduler est l'add-on qui va nous permettre d'ex√©cuter des t√¢ches √† des intervalles r√©guliers personnalisables.</p>

    <p>Installons-le dans notre projet¬†:</p>

    <pre><code class="language-sh">$ heroku addons:create scheduler:standard
Creating scheduler:standard on stark-escarpment-87840... free
This add-on consumes dyno hours, which could impact your monthly bill. To learn more:
http://devcenter.heroku.com/addons_with_dyno_hour_usage

To manage scheduled jobs run:
heroku addons:open scheduler

Created scheduler-reticulated-65091
Use heroku addons:docs scheduler to view documentation</code></pre>

    <p>Et maintenant on va ouvrir cet add-on pour le personnaliser¬†:</p>

    <pre><code class="language-sh">$ heroku addons:open scheduler</code></pre>

    <p>Vous devriez voir ceci¬†:</p>

    <p><img src="{{ asset('bundles/afsyfront/images/avent/2017/03/scheduler_home.jpg') }}" alt="Scheduler home" title=""></p>

    <p>Le bouton <code>Add new job</code> va nous permettre de faire exactement ce qu'il nous faut !</p>

    <p><img src="{{ asset('bundles/afsyfront/images/avent/2017/03/scheduler_job.jpg') }}" alt="Scheduler job" title=""></p>

    <p>Alors la fr√©quence est clairement moins flexible qu'une <em>vraie</em> t√¢che <code>cron</code>, mais pour les usages les plus simples, √ßa reste la meilleure solution. Sinon, il faudra un worker, ce qui est plus complexe √† mettre en place (et est plus cher). </p>

    <p>On peut en tout cas ex√©cuter notre t√¢che¬†:</p>

    <ul>
        <li>Une fois par jour √† une heure/demi-heure donn√©e.</li>
        <li>Toutes les heures, √† la dizaine de minutes donn√©e.</li>
        <li>Toutes les 10mn √† partir du moment o√π la t√¢che est cr√©√©e / mise √† jour.</li>
    </ul>

    <p>Une fois votre commande configur√©e, vous pouvez attendre quelques minutes que celle-ci s'ex√©cute.</p>

    <p>Lorsque le temps est pass√©, vous pouvez voir les logs¬†:</p>

    <pre><code class="language-sh">$ heroku logs | grep scheduler
2017-12-01T21:02:56.302995+00:00 heroku[scheduler.8108]: Starting process with command `php bin/console app:simple-message`
2017-12-01T21:02:56.979408+00:00 heroku[scheduler.8108]: State changed from starting to up
2017-12-01T21:02:58.362544+00:00 app[scheduler.8108]: [2017-12-01 21:02:58] Stdout message
2017-12-01T21:02:58.482250+00:00 app[scheduler.8108]: [2017-12-01 21:02:58] Stderr message
2017-12-01T21:02:58.486752+00:00 heroku[scheduler.8108]: Process exited with status 0
2017-12-01T21:02:58.504268+00:00 heroku[scheduler.8108]: State changed from up to complete</code></pre>

    <p>On voit bien nos messages <code>Stdout</code> et <code>Stderr</code> s'afficher !</p>

    <p>Et voil√†, nous avons une routine correctement configur√©e !</p>

    <p><strong>Note¬†:</strong> Attention au temps d'ex√©cution de vos commandes, car celui-ci sera d√©compt√© du temps consomm√© de votre dyno, qui peut vous √™tre factur√© selon votre abonnement. Ceci dit, une commande qui dure 5 secondes, ex√©cut√©e 144 fois par jour, cela fait 21600 secondes de consomm√©es dans le mois. Ce n'est pas grand chose compar√© aux 2592000 secondes pour un serveur web allum√© 24h/24‚Ä¶ </p>

    <h3 id="am√©liorer-son-environnement-heroku">Am√©liorer son environnement Heroku</h3>

    <p>Heroku √©tant plein d'addons, pour la plupart gratuits, je vous en recommande quelques-uns¬†:</p>

    <ul>
        <li><a href="https://elements.heroku.com/addons/autobus">Autobus</a>, un syst√®me de backups pour votre base de donn√©es, tr√®s pratique et dont le plan gratuit est id√©al pour les projets simples.</li>
        <li><a href="https://elements.heroku.com/addons/blackfire">Blackfire</a> (beta), l'ind√©modable outil de profilage pour tous nos projets PHP !</li>
        <li><a href="https://elements.heroku.com/addons/mailgun">Mailgun</a>, excellent outil d'envoi d'emails, qui peut √™tre directement branch√© √† Swiftmailer gr√¢ce √† la variable d'environnement <code>MAILER_URL</code>, et dont le plan gratuit avec 400 mails par jour (soit 12000 par mois) est largement suffisant pour la plupart des projets (le plan suivant √©tant √† 50000 mails par mois‚Ä¶).</li>
        <li><a href="https://elements.heroku.com/addons/papertrail">Papertrail</a>, outil de monitoring des logs de tous vos dynos, tr√®s utile pour garder un ≈ìil sur vos erreurs PHP. Il peut vous envoyer un mail lorsqu'il y a des erreurs √† intervalles r√©guliers, permet de cr√©er des filtres pour les types d'erreurs, de commandes, etc.. Le gros avantage c'est que nous n'avons m√™me pas besoin de configurer monolog autrement qu'en lui disant de tout envoyer vers <code>php://stderr</code> !</li>
        <li><a href="https://devcenter.heroku.com/articles/deploy-hooks">Deploy Hooks</a>, un bon moyen d'envoyer une petite notification de succ√®s d'un d√©ploiement sur Slack, IRC, par email ou m√™me avec une requ√™te HTTP √† n'importe quelle URL. </li>
    </ul>

    <h3 id="conclusion">Conclusion</h3>

    <p>Heroku est un PaaS tr√®s simple √† utiliser, mais surtout, il est excellent pour le test, car il suffit d'utilier des <a href="https://devcenter.heroku.com/articles/github-integration-review-apps">review apps</a> pour la preprod, et √©tant donn√© que la preprod n'est pas utilis√©e non-stop, on peut largement utiliser l'abonnement gratuit pour √ßa !</p>

    <p>Pour l'upload et le stockage de fichiers, il vous faudra utiliser Amazon S3 et vous r√©f√©rer √† la documentation en <a href="https://devcenter.heroku.com/articles/s3">suivant ce lien</a> et utiliser les r√©f√©rences √† S3 dans votre code.</p>

    <hr>

    <p>Chez <a href="https://www.studio-agate.com/fr/">Agate √âditions</a>, nous avons fait le choix d'utiliser Heroku pour notre projet, une application monolithique multi-domaines qui h√©berge des portails et des sites relatifs aux jeux de r√¥le du studio, notamment un gestionnaire de personnages et une application de cartographie interactive. C'est parfait pour nos besoins financiers et c'est stable au niveau performances, m√™me avec un plan de base !</p>

    <p>Merci de cette lecture ! Vous pouvez me retrouver un peu partout sur le web avec le pseudo <code>@pierstoval</code> !</p>

    <p>üåë üåò üåó üåñ üåï üåî üåì üåí üåë</p>
{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('bundles/afsyfront/images/avent/alex-rock-ancelet.jpg') }}" alt="Alex Rock Ancelet" />
{% endblock %}

{% block article_bio %}
<h3><a href="{% block author_url %}https://twitter.com/pierstoval{% endblock %}" target="_blank">{% block article_author %}Alex Rock Ancelet{% endblock %}</a></h3>
<p>
    Alex travaille en tant que formateur &amp; d√©veloppeur chez SensioLabs, et est √©galement lead tech pour le studio d'√©dition Agate.<br>
    Il a commenc√© la programmation tr√®s jeune, mais ne l'a gard√©e que comme loisir, a appris seul sans √©tudes ni formation sp√©cifique, mais a un go√ªt prononc√© pour le partage et la transmission de connaissances.
</p>
{% endblock %}
