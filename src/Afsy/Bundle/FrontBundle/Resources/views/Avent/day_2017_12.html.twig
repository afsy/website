{% extends 'AfsyFrontBundle:Avent:day.html.twig' %}

{% set year = 2017 %}

{% block article_title "Jour 12 - Serverless, PHP et Symfony" %}

{% block article_content %}
    <style>
        em {
            font-family: sans-serif;
        }
    </style>
    <h1 id="serverless-php-et-symfony">Serverless, PHP et Symfony</h1>

    <p>Depuis une dizaine dâ€™annÃ©es, le monde du dÃ©ploiement et de lâ€™hÃ©bergement dâ€™applications web change Ã  une vitesse phÃ©nomÃ©nale. Lâ€™arrivÃ©e de AWS et de leurs VMs en 2 clics, puis lâ€™arrivÃ©e de PaaS comme Heroku (d'ailleurs, allez voir <a href="https://afsy.fr/avent/2017/03-deployer-un-projet-symfony-flex-sur-heroku">l'article d'Alex sur Symfony & Heroku</a> si vous ne l'avez pas encore lu!), puis lâ€™arrivÃ©e des containers. Dans le viseur aujourdâ€™hui, ce sont les FaaS (Functions as a Service) ou "serverlessâ€. </p>

    <p>Aujourdâ€™hui, nous allons voir en quoi ces nouvelles offres "serverlessâ€ ont un intÃ©rÃªt pour nous, utilisateurs et crÃ©ateurs dâ€™applications web. Nous allons Ã©galement voir comment utiliser ces offres pour votre application Symfony.</p>



    <h2 id="quest-ce-que-serverless">Quâ€™est-ce que serverless</h2>

    <p>Dâ€™aprÃ¨s le nom, en francais "sans-serveurâ€, on peut comprendre lâ€™idÃ©e: il nâ€™y a pas de serveur Ã  gÃ©rer. Cela veut dire pas de machine dÃ©diÃ©e chez OVH, pas de EC2 chez AWS ou encore pas de dyno chez Heroku. </p>

    <p>Câ€™est tout simplement un PaaS donc? Ou bien un hÃ©bergement mutualisÃ© Ã  lâ€™ancienne? Eh bienâ€¦ non plus. On peut rÃ©sumer les "FaaSâ€ par les points suivants:</p>

    <ol>
        <li><p><strong>Pay-as-you <em>really</em> go</strong>. Toutes les autres alternatives, Ã  ma conaissance, facture un prix de base par mois, qui inclus une certaine quantitÃ© de trafic et/ou ressources utilisable. Pour ces offres-lÃ , vous ne payez quâ€™au nombre dâ€™exÃ©cutions.  <br>
                Câ€™est-Ã -dire: 0 requÃªtes = 0 â‚¬.</p></li>
        <li><p><strong>Stateless</strong>. Chaque exÃ©cution de notre fonction est indÃ©pendante. Typiquement, on ne va pas pouvoir Ã©crire sur le disque dur pour la prochaine requÃªte. Il faut aussi imaginer que notre fonction va Ãªtre exÃ©cutÃ©e quelque part, mais nous nâ€™avons aucun contrÃ´le sur lâ€™endroit.</p></li>
        <li><p><strong>Scalable</strong>. Il nâ€™y a plus de serveurs (Ã  votre connaissance). Ces fonctions sont des processus stateless exÃ©cutÃ©s pour quelques millisecondes voir secondes. Ces contraintes leur permettent dâ€™Ãªtre exÃ©cutÃ©es sur une quantitÃ© trÃ¨s importante de machines, en parallÃ¨le, et donc de rÃ©pondre Ã  des pics de demande extrÃªmement importants.</p></li>
    </ol>

    <p>Cela nous donne une solution qui ne coute rien lorsque non utilisÃ©e, mais qui permet de "scalerâ€ (ou de rÃ©pondre Ã  de gros pics de trafic) en quelques secondes. Un bon exemple pour prouver lâ€™intÃ©rÃªt de telles infrastructures est <a href="http://www.bbc.co.uk/blogs/internet/entries/683c2e2a-c1ee-490b-9a97-23214505aba4">la BBC</a>: ils utilisent AWS Lamba pour faire du rendu de frames vidÃ©os en temps rÃ©el. Lorsque aucun rendu nâ€™est Ã  effectuer, cela ne leur coute rien, mais ils peuvent absorber une grande quantitÃ© dâ€™exÃ©cution, sans ne rien changer Ã  leur infrastructure.</p>



    <h2 id="qui-sont-les-principaux-acteurs-dans-ce-domaine">Qui sont les principaux acteurs dans ce domaine?</h2>

    <p>Vous lâ€™aurez sans doutes compris, Amazon Web Services a un FaaS nommÃ© <a href="http://docs.aws.amazon.com/lambda/latest/dg/welcome.html">"AWS Lambaâ€</a>, Google Cloud a les <a href="https://cloud.google.com/functions/">"Google Cloud Functionsâ€</a>, Azureâ€¦ <a href="https://azure.microsoft.com/en-gb/services/functions/">"Functionsâ€</a>. Ces trois offres sont complÃ¨tes et extrÃªmement bien intÃ©grÃ©es aux diffÃ©rentes plateformes, mais sont propriÃ©taires. Puisque nous parlons de Symfony, il me semble important de souligner les alternatives open-sources, que sont:</p>

    <ol>
        <li><p><a href="https://openwhisk.apache.org">OpenWhisk</a>, un projet de la fondation Apache. Il est important de noter que OpenWhisk est disponible en version "managÃ©eâ€ par IBM. Ce sont les <a href="https://console.bluemix.net/openwhisk/">IBM Cloud Functions</a>.</p></li>
        <li><p><a href="https://github.com/openfaas/faas">OpenFaaS</a> et <a href="https://github.com/fission/fission">Fission</a>, sont tous les deux basÃ©s sur lâ€™utilisation de containers Docker. Il vous "suffitâ€ dâ€™un <a href="https://kubernetes.io/">cluster Kubernetes</a> pour faire tourner ces deux plateformes. </p></li>
    </ol>



    <h2 id="php-dans-tout-Ã§a">PHP dans tout Ã§a?</h2>

    <p>Mis Ã  part pour les alternatives open-sources, PHP nâ€™est pas vraiment lâ€™ami des trois gros "cloudsâ€. Node.js et Go sont les grands gagnants, PHP nâ€™est mÃªme pas officiellement supportÃ© par lâ€™un dâ€™entre eux. La seule faÃ§on de lancer du PHP dans ces clouds est en utilisant un "shimâ€. <a href="https://aws.amazon.com/blogs/compute/scripting-languages-for-aws-lambda-running-php-ruby-and-go/">On package le binaire de PHP dans la fonction, et on demande Ã  un petit script Node de lancer le PHP</a> (je vous assure, câ€™est mÃªme dans leurs documentations officielles !). </p>

    <p><em>Pourtantâ€¦ PHP est fait pour Ã§a ! PHP est fait pour lancer des scripts trÃ¨s courts. Alors que de lâ€™autre cÃ´tÃ© de la barriÃ¨re, Node et Go ont Ã©tÃ© crÃ©Ã©s pour les scripts longs. Je nâ€™ai pas la rÃ©ponse Ã  "pourquoiâ€ mais je trouve Ã§a trÃ¨s Ã©tonnant.</em></p>



    <h2 id="deployer-notre-application-symfony">Deployer notre application Symfony</h2>

    <p>Nous allons crÃ©er et dÃ©ployer notre application Symfony 4, dans une fonction OpenWhisk. Nous utilisons cette plateforme pour 3 raisons: câ€™est une plateforme de FaaS open-source, elle supporte nativement PHP et elle dispose dâ€™une version "managÃ©eâ€ sur le Cloud dâ€™IBM. Je vous encourage grandement Ã  essayer par vous mÃªme avec IBM Cloud Functions, câ€™est gratuit les premiers 400,000 GB-seconds (câ€™est bien plus quâ€™il vous faut pour votre "side projectâ€ !).</p>

    <ol>
        <li>
            <strong>Configurer <code class="language-none">wsk</code>, le client OpenWhisk</strong>
            <p>Si vous suivez mon conseil, crÃ©ez votre compte IBM Cloud et suivez <a href="https://console.bluemix.net/openwhisk/learn/cli">la documentation pour configurer "wskâ€</a>. Sinon, configurez "wskâ€ par vous meme :)</p>
        </li>
        <li>
            <strong>Creer votre application Symfony</strong>
            <p>Vous avez probablement lu <a href="https://afsy.fr/avent/2017/02-la-nouvelle-configuration-par-defaut-de-symfony4">le post de Nicolas</a>, et savez donc que lâ€™on dÃ©marre une application Symfony 4 avec <code class="language-none">composer</code>:</p>
            <pre><code class="language-none">$ composer create-project symfony/skeleton my-app &amp;&amp; cd my-app</code></pre>
        </li>
        <li>
            <strong>Installer le "bridgeâ€ OpenWhisk</strong>
            <pre><code class="language-none">$ composer req sroze/openwhisk-bundle</code></pre>
        </li>
        <li>
            <strong>PrÃ©parer lâ€™archive de votre application</strong>
            <pre><code class="language-none">$ zip -X -r ../my-app.zip * .env*</code></pre>
        </li>
        <li>
            <strong>CrÃ©er ou mettre Ã  jour votre fonction</strong>
            <pre><code class="language-none">$ wsk action update skeleton-symfony --kind php:7.1 skeleton-symfony.zip --web true</code></pre>
        </li>
        <li>
            <strong>Recuperer lâ€™URL de la fonction</strong>
            <pre><code class="language-none">$ wsk action get skeleton-symfony --url&lt;/td&gt;</code></pre>
            <p>Ouvrez la fonction et vous devriez avoir lâ€™application !</p>
        </li>
    </ol>


    <h2 id="que-cest-il-passÃ©">Que sâ€™est-il passÃ© ?</h2>

    <p>Ces quelques Ã©tapes trÃ¨s simples pour dÃ©ployer votre application Symfony peuvent Ãªtre troublantes. Nous allons dÃ©tailler ce quâ€™il sâ€™est passÃ©.</p>

    <ol>
        <li><p>Vous avez configurÃ© votre environnement local pour pouvoir parler au serveur OpenWhisk. Rien de magique la dedans.</p></li>
        <li><p>Vous avez crÃ©Ã© une application Symfony. Câ€™est trÃ¨s simple, câ€™est le tout nouveau skeleton Symfony. Je vous recommande <a href="https://afsy.fr/avent/2017/02-la-nouvelle-configuration-par-defaut-de-symfony4">lâ€™article de Nicolas pour en savoir plus sur Symfony 4</a>.</p></li>
        <li><p>Vous avez installÃ© le bridge OpenWhisk pour votre application Symfony. Câ€™est <a href="https://github.com/sroze/openwhisk-bundle">un package</a> et avant tout <a href="https://github.com/symfony/recipes-contrib/tree/master/sroze/openwhisk-bundle/0.2">une recipe pour "flexâ€</a>, le nouveau systÃ¨me de gestion de configuration de Symfony. Cette "recetteâ€ a crÃ©Ã© <a href="https://github.com/symfony/recipes-contrib/blob/master/sroze/openwhisk-bundle/0.2/index.php#L33">un nouveau front-controller</a> (remplacant votre <code class="language-none">public/index.php</code>) qui va Ãªtre exÃ©cutÃ© lorsque la fonction est exÃ©cutÃ©e dans "le cloudâ€. Ce front-controller va transformer la requÃªte de type <a href="https://console.bluemix.net/docs/openwhisk/openwhisk_webactions.html">OpenWhisk Web Action</a> en object <a href="https://symfony.com/doc/3.3/components/http_foundation.html#request">HttpFoundation Request</a>, puis faire lâ€™inverse pour la rÃ©ponse.</p></li>
        <li><p>Puisquâ€™une application Symfony est un ensemble de fichiers, nous devons utiliser une application de type "packageâ€. Ce type dâ€™application est tout simplement un fichier ZIP de votre dossier.</p></li>
        <li><p>Vous avez crÃ©Ã© la fonction dans OpenWhisk. Typiquement, cela a uploadÃ© le fichier ZIP quelque part accessible par les containers lanÃ§ant vos fichiers PHP. Vous avez Ã©galement utilisÃ© le flag <code class="language-none">--web</code>, qui prÃ©cise a OpenWhisk de faire en sorte que cette fonction soit accessible "depuis le webâ€.</p></li>
        <li><p>Une fois la fonction crÃ©Ã©e, il ne vous reste plus quâ€™a rÃ©cuperer lâ€™URL de la fonction pour lâ€™exÃ©cuter.</p></li>
    </ol>



    <h2 id="serverless-le-framework">"serverlessâ€, le framework</h2>

    <p>En gÃ©nÃ©ral, vous nâ€™allez pas dÃ©ployer une seule fonction mais plusieurs. Vous allez nâ€™allez pas utiliser que HTTP comme dÃ©clencheur de fonction, mais aussi un systÃ¨me de queue, un Ã©vÃ©nement dans une base de donnÃ©es, etcâ€¦ </p>

    <p>GÃ©rer "manuellementâ€ tous ces cas peut Ãªtre beaucoup de boulot, trÃ¨s rÃ©pÃ©titif, et difficile a maintenir. Câ€™est pour Ã§a quâ€™existe <a href="https://serverless.com">"serverlessâ€</a>, un framework Ã©crit en Node, qui permet de simplifier la gestion de nos fonctions. Il permet aussi de faire une abstraction avec OpenWhisk, AWS Lamba et toutes ces plateformes.</p>

    <p>Installez serverless et son plugin OpenWhisk, et crÃ©ez le fichier <code class="language-none">serverless.yml</code> dans le dossier parent de lâ€™application "my-appâ€ que nous venons de crÃ©er plus tÃ´t:</p>



    <pre><code class="language-yaml">service: my-project

provider:
  name: openwhisk
  runtime: php

package:
  individually: true

functions:
  first-app:
    handler: my-app/index.main
  2nd-app:
    handler: 2nd-app/index.main

plugins:
  - serverless-openwhisk</code></pre>

    <p>DÃ©ployez !</p>



    <pre><code class="language-none">$ serverless deploy</code></pre>



    <h2 id="conclusion">Conclusion</h2>

    <p>Jâ€™espÃ¨re que cet article vous a permis dâ€™en savoir plus a propos de ces "functions as a serviceâ€. Il est clair que ce nouveau genre dâ€™offre constitue un futur encore plus simple et moins coÃ»teux pour expÃ©rimenter divers idÃ©es, tout en crÃ©ant des architectures "scalable-nativeâ€. Les outils sont toujours relativement expÃ©rimentaux et rares, mais je nâ€™ai aucun doute quâ€™ensemble nous pouvons amÃ©liorer les outils pour Symfony ! </p>

    <p>Happy serverlessing ğŸ˜</p>
{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('bundles/afsyfront/images/avent/samuel-roze.jpeg') }}" alt="Samuel Roze" />
{% endblock %}

{% block article_bio %}
<h2><a href="{% block author_url %}https://twitter.com/samuelroze?lang=fr{% endblock %}" target="_blank">{% block article_author %}Samuel Roze{% endblock %}</a></h2>
<p>
    Samuel a crÃ©Ã© et continue de maintenir ContinuousPipe, un outil de deployment pour les applications containerisÃ©es, basÃ© sur Kubernetes.
    <br>Contributeur Ã  Symfony, mainteneur de ApiPlatform et contributeur Ã  de nombreux projects open-source, il aide de multiples startups Ã  prototyper et designer leur architectures technique pour Kamet Ventures, un incubateur londonnien.
</p>
{% endblock %}
